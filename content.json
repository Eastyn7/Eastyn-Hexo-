{"meta":{"title":"Eastyn的博客","subtitle":"","description":"","author":"Eastyn","url":"http://eastyn7.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-09-28T17:32:05.000Z","updated":"2024-09-28T17:34:04.765Z","comments":false,"path":"about/index.html","permalink":"http://eastyn7.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2024-09-28T13:04:35.234Z","updated":"2024-09-28T13:04:35.234Z","comments":true,"path":"2024/09/28/hello-world/","permalink":"http://eastyn7.github.io/2024/09/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"HEXO搭建博客平台","slug":"利用HEXO搭搭建自己的博客","date":"2024-09-28T12:58:51.580Z","updated":"2024-09-29T13:11:17.384Z","comments":true,"path":"2024/09/28/利用HEXO搭搭建自己的博客/","permalink":"http://eastyn7.github.io/2024/09/28/%E5%88%A9%E7%94%A8HEXO%E6%90%AD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"HEXO搭建博客平台本机环境 Win11 node.js：18.17.0 npm：10.8.2 安装下载hexo1npm install -g hexo-cli hexo -v 验证并查看版本 创建项目文件夹1hexo init myblog 安装12cd myblognpm install 启动服务12hexo ghexo server 在GitHub创建仓库安装hexo上传插件1npm install hexo-deployer-git --save 修改hexo配置文件指定仓库路径在文件夹中直接打开_config.yml文件修改 deploy: ​ type: git ​ repo : git地址 ​ branch: master 推送到GitHub1hexo d 跟新完 清理：hexo clean 构建：hexo g 上传：hexo d","categories":[],"tags":[]},{"title":"","slug":"青队云平台开发文档","date":"2024-09-04T15:00:04.749Z","updated":"2024-09-29T13:24:15.184Z","comments":true,"path":"2024/09/04/青队云平台开发文档/","permalink":"http://eastyn7.github.io/2024/09/04/%E9%9D%92%E9%98%9F%E4%BA%91%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/","excerpt":"","text":"title：青队云平台开发青队云平台开发文档💕启动时间：2024.09.04 项目概述背景随着志愿服务在高校中的蓬勃发展，“小红帽”常青藤青年志愿者服务队【以下简称青队】逐渐成为学院内外各类公益活动的重要组织者。作为一个由热心青年学生组成的志愿者队伍，我们的成员在多个领域积极参与，展现了良好的精神风貌和社会责任感。为了更好地提升服务队的内部管理和对外宣传，我们希望通过开发一个内部管理和展示平台，强化队伍凝聚力和成员归属感，同时向公众展示我们的成果和精神风貌。 当前问题和挑战1、队伍形象展示不足：服务队在学院和社会上的影响力有限，缺乏一个集中展示服务队历史、成就和活动的窗口，使外界难以充分了解我们的团队文化和核心价值观。 2、信息发布不及时：当前活动和内部信息的发布主要依赖于微信群、QQ群等非集中化渠道，容易导致信息遗漏或传播不及时，影响活动的参与率和团队沟通效率。 3、志愿精神传递不足：在提升成员志愿服务精神、技能培训和经验分享方面缺少有效的工具和手段，难以为新成员提供系统性的成长路径和支持。 项目目标本项目旨在为青队开发一个专属的云平台，以解决以上问题，并实现以下目标： 1、展示队伍形象和成就：通过平台展示服务队的历史、团队文化、活动成果和优秀队员的风采，加强公众对服务队的认识和支持。 2、提升信息发布和沟通效率：通过平台发布公告、活动预告和内部信息，确保成员能够及时获取最新信息，提升队内沟通效率。 3、促进志愿精神传播与成长：提供志愿者学习资源、经验分享和培训支持，帮助成员成长，并有效传播志愿服务精神。 数据库设计登录信息表（user_auth)1234567891011CREATE TABLE `user_auth` ( `auth_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;认证ID&#x27;, `student_id` varchar(12) NOT NULL COMMENT &#x27;学号&#x27;, `email` varchar(100) NOT NULL COMMENT &#x27;邮箱，要求@ctbu.edu.cn结尾&#x27;, `password_hash` varchar(255) NOT NULL COMMENT &#x27;密码哈希值&#x27;, `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;账号创建时间&#x27;, `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;最后更新时间&#x27;, PRIMARY KEY (`auth_id`), UNIQUE KEY `unique_email` (`email`), -- 确保邮箱唯一 UNIQUE KEY `unique_student_id` (`student_id`) -- 确保学号唯一) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; 用户表(users)1234567891011121314CREATE TABLE `users` ( `id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;用户ID&#x27;, `auth_id` int NOT NULL COMMENT &#x27;关联认证表的外键&#x27;, `role` tinyint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;用户角色（0=普通用户, 1=管理员）&#x27;, `username` varchar(64) NOT NULL COMMENT &#x27;用户名&#x27;, `name` varchar(255) NOT NULL COMMENT &#x27;真实姓名&#x27;, `gender` tinyint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别（0=未指定, 1=男, 2=女）&#x27;, `avatar` varchar(255) DEFAULT NULL COMMENT &#x27;头像URL&#x27;, `mobile` varchar(11) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`), FOREIGN KEY (`auth_id`) REFERENCES `user_auth`(`auth_id`) ON DELETE CASCADE -- 关联外键，支持级联删除) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; 功能设计首页（&#x2F;home） 轮播图 小公告 队徽队名 功能宫格【校园服务通、爱心雨伞、服务队活动风采、志愿活动报名、关于青队、用户意见反馈】 个人中心（&#x2F;user） 未登录情况 默认登录栏（默认头像、点击登录） 选择列表（个人资料、权限申请、使用指南、设置）【需要登录之后才能点击使用】 已登录情况 已登录状态栏（登录头像、名称） 选择列表（个人资料、权限申请（审核）、?后台管理、使用指南、设置） 关于青队（About Us）项目开发创建项目1pnpm create vue 配置Vant添加vant 1pnpm add vant 安装自动导入插件 1pnpm add @vant/auto-import-resolver unplugin-vue-components unplugin-auto-import -D 配置自动导入 1234567891011121314151617181920212223242526import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;;import Components from &#x27;unplugin-vue-components/vite&#x27;;import &#123; VantResolver &#125; from &#x27;@vant/auto-import-resolver&#x27;;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; // vant按需导入 resolvers: [VantResolver()], &#125;), Components(&#123; resolvers: [VantResolver()], &#125;) ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;&#125;) 配置自动导入和组件1234567891011121314151617181920212223242526272829AutoImport(&#123; include: [ /\\.[tj]sx?$/, // .ts, .tsx, .js, .jsx /\\.vue$/, /\\.vue\\?vue/, // .vue /\\.md$/ // .md ], imports: [&#x27;vue&#x27;, &#x27;vue-router&#x27;, &#x27;pinia&#x27;], // 配置导出的文件 dts: &#x27;src/auto-import.d.ts&#x27;, // vue、vue-router ts类型导出位置 // vant按需导入 resolvers: [VantResolver()], // eslint 配置 eslintrc: &#123; enabled: true, // 当配置 enabled: true 时，会根据 filepath 配置的路径生成一个 .eslintrc-auto-import.json 文件 filepath: &#x27;src/.eslintrc-auto-import.json&#x27;, globalsPropValue: true &#125; &#125;), Components(&#123; // 搜索子目录 deep: true, // 组件有效的扩展名 extensions: [&#x27;vue&#x27;, &#x27;js&#x27;, &#x27;jsx&#x27;, &#x27;ts&#x27;, &#x27;tsx&#x27;, &#x27;.mjs&#x27;], include: [/\\.vue$/, /\\.vue\\?vue/, /\\.js$/, /\\.jsx$/, /\\.ts$/, /\\.tsx$/], resolvers: [VantResolver()], dirs: [&#x27;src/components&#x27;], dts: &#x27;src/components.d.ts&#x27;, directives: true &#125;) 配置Eslint和Prettier123456789101112131415161718192021rules: &#123; &#x27;prettier/prettier&#x27;: [ &#x27;warn&#x27;, &#123; singleQuote: true, semi: false, printWidth: 100, trailingComma: &#x27;none&#x27;, endOfLine: &#x27;auto&#x27; &#125; ], &#x27;vue/multi-word-component-names&#x27;: [ &#x27;warn&#x27;, &#123; ignores: [&#x27;index&#x27;] &#125; ], &#x27;vue/no-setup-props-destructure&#x27;: [&#x27;off&#x27;] // &#x27;no-undef&#x27;: &#x27;error&#x27;&#125; 配置Viewport安装插件 1pnpm install postcss-px-to-viewport -D 配置 12345678910111213141516171819/* eslint-env node */// postcss.config.cjsmodule.exports = &#123; plugins: &#123; &#x27;postcss-px-to-viewport&#x27;: &#123; uniToConvert: &#x27;px&#x27;, // 需要转换的单位 &#x27;默认px&#x27; viewportWidth: 375, // 设计稿的视口宽度 unitPrecision: 5, // 单位转换后保留的小数位数 proList: [&#x27;*&#x27;], // 要进行转换的属性列表 ,*表示匹配所有 viewportUnit: &#x27;vw&#x27;, // 转换后的视口单位 selectorBlackList: [&#x27;.ignore&#x27;, &#x27;.hairlines&#x27;], // 不转换的选择器列表 fontViewportUnit: &#x27;vw&#x27;, // 转换后字体使用的视口单位 minPixelValue: 1, // 设置最小的转换数值 replace: true, // 是否直接转化而不添加备用属性 mediaQuery: true, // 是否允许在媒体查询中转换 exclude: [/node_modules/] // 忽略某些文件夹下的文件 &#125;, &#125;,&#125;; 配置Axios安装Axios 1pnpm add axios 配置Request文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import axios from &#x27;axios&#x27;import type &#123; InternalAxiosRequestConfig &#125; from &#x27;axios&#x27;import &#123; getLocalData, removeLocalData, isLogin &#125; from &#x27;@/utils/util&#x27;// 自定义请求配置接口，扩展了 Axios 的配置选项，增加了 needToken 属性interface CustomRequestConfig extends InternalAxiosRequestConfig &#123; needToken?: boolean // 标识请求是否需要携带Token&#125;// 创建axios实例，并设置基础配置const http = axios.create(&#123; baseURL: import.meta.env.VITE_BASE_URL, // API的基础URL，使用Vite的环境变量来设置 timeout: 10000 // 请求超时时间为10秒&#125;)// 请求拦截器：在请求发送之前做一些处理http.interceptors.request.use( (config: CustomRequestConfig) =&gt; &#123; // 判断当前请求是否需要Token if (config.needToken) &#123; // 检查是否已登录 if (isLogin()) &#123; // 从本地存储中获取用户信息 const userinfo = getLocalData(&#x27;userinfo&#x27;) if (userinfo) &#123; // 如果用户信息存在，将Token添加到请求头中 config.headers[&#x27;Authorization&#x27;] = `Bearer $&#123;userinfo.sk&#125;` // sk 为用户密钥字段 &#125; &#125; // 如果用户未登录，但本地有Token过期时间 else if (getLocalData(&#x27;token_expires_at&#x27;)) &#123; // 移除过期的用户信息和Token removeLocalData(&#x27;userinfo&#x27;) removeLocalData(&#x27;token_expires_at&#x27;) // 提示用户登录已过期 showFailToast(&#x27;登录已过期，请重新登录&#x27;) &#125; // 用户未登录且没有过期的Token else &#123; // 提示用户先登录 showFailToast(&#x27;请先登录&#x27;) &#125; &#125; // 为所有请求设置请求头，指定请求内容类型为x-www-form-urlencoded config.headers[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27; // 返回处理后的请求配置 return config &#125;, (error) =&gt; &#123; // 如果请求发生错误，直接返回错误 return Promise.reject(error) &#125;)// 响应拦截器：在响应返回之后做一些处理http.interceptors.response.use( (response) =&gt; &#123; // 只返回响应的data部分，简化后续调用的数据处理 return response.data &#125;, (error) =&gt; &#123; // 如果响应发生错误，返回错误 return Promise.reject(error) &#125;)// 导出处理好的 http 实例export default http 配置Pinia安装插件 1pnpm add pinia-plugin-persistedstate -D 在仓库中导入 123456789101112131415import &#123; createPinia &#125; from &#x27;pinia&#x27;import persist from &#x27;pinia-plugin-persistedstate&#x27;const pinia = createPinia()pinia.use(persist)import &#123; useCounterStore &#125; from &#x27;./counter&#x27; // 举例导入export default piniaexport const useStore = () =&gt; &#123; return &#123; counter: useCounterStore() &#125;&#125; 配置Vant底部安全区适配123/* index.html */&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover&quot;/&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/viewportFit.css&quot;&gt; 12345678/* viewportFit.css *//* 适配 iphone 底部安全区（指示条，配合index.html &lt;meta name=&quot;viewport&quot; ... /&gt;使用 */@supports (bottom: env(safe-area-inset-bottom))&#123; #app &#123; padding-bottom: constant(safe-area-inset-bottom);/* 兼容ios&lt;11.2 */ padding-bottom: env(safe-area-inset-bottom);/* 兼容ios&gt;=11.2 */ &#125;&#125; 配置全局样式1234567891011121314151617181920212223242526/* src/styles/index.css */#app &#123; max-width: 1280px; margin: 0 auto; padding: 0.5rem; font-weight: normal;&#125;html &#123; line-height: 1.2;&#125;body &#123; background-color: rgba(194, 194, 194, 0.131); font-family: &#x27;KaiTi&#x27;, &#x27;楷体&#x27;, &#x27;STKaiti&#x27;, &#x27;SimSun&#x27;, &#x27;黑体&#x27;, &#x27;Heiti SC&#x27;, &#x27;Arial&#x27;, sans-serif; color: #3e3e3e; margin: 0; padding: 0; box-sizing: border-box;&#125;h1, h2, h3, h4, h5, h6 &#123; color: #222; font-family: &#x27;KaiTi&#x27;, &#x27;楷体&#x27;;&#125; 配置路由1234567891011121314151617181920212223242526272829303132import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import indexRoutes from &#x27;./routes&#x27;const router = createRouter(&#123; history: createWebHashHistory(), routes: [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/home&#x27;, children: [ &#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: () =&gt; import(&#x27;@/views/Home/HomeView.vue&#x27;) &#125;, &#123; path: &#x27;/user&#x27;, name: &#x27;User&#x27;, component: () =&gt; import(&#x27;@/views/User/UserView.vue&#x27;) &#125;, &#123; path: &#x27;/notice&#x27;, name: &#x27;Notice&#x27;, component: () =&gt; import(&#x27;@/views/Notice/NoticeView.vue&#x27;) &#125; ] &#125;, ...indexRoutes //基础功能页面 ]&#125;)export default router 其他路由 1234567891011121314151617181920212223242526272829303132333435/* indexRoutes.ts */const routes = [ &#123; path: &#x27;/campusservice&#x27;, name: &#x27;CampusService&#x27;, component: () =&gt; import(&#x27;@/views/CampusService/CampusService.vue&#x27;) &#125;, &#123; path: &#x27;/loveumbrella&#x27;, name: &#x27;LoveUmbrella&#x27;, component: () =&gt; import(&#x27;@/views/LoveUmbrella/LoveUmbrella.vue&#x27;) &#125;, &#123; path: &#x27;/activities&#x27;, name: &#x27;Activities&#x27;, component: () =&gt; import(&#x27;@/views/Activities/Activities.vue&#x27;) &#125;, &#123; path: &#x27;/signup&#x27;, name: &#x27;SignUp&#x27;, component: () =&gt; import(&#x27;@/views/SignUp/SignUp.vue&#x27;) &#125;, &#123; path: &#x27;/aboutus&#x27;, name: &#x27;AboutUs&#x27;, component: () =&gt; import(&#x27;@/views/AboutUs/AboutUs.vue&#x27;) &#125;, &#123; path: &#x27;/feedback&#x27;, name: &#x27;Feedback&#x27;, component: () =&gt; import(&#x27;@/views/Feedback/Feedback.vue&#x27;) &#125;]export default routes 配置阿里图标 在阿里图标官网创建项目，并将选好的图标保存到项目中，再将项目下载下来 把下载的项目中的文件（除了demo.css和demo_index.html文件）保存至该项目中 在main.ts中导入iconfont.css文件 在项目中使用icon=&quot; icon-great-activities&quot; icon-prefix=&quot;iconfont&quot;【需要注意的是图标类名前必须加一个空格】 App.vue12345678910111213141516171819202122232425262728293031323334&lt;script setup lang=&quot;ts&quot;&gt;const route = useRoute()&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;layout&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;van-tabbar route v-if=&quot;[&#x27;/&#x27;, &#x27;/home&#x27;, &#x27;/notice&#x27;, &#x27;/user&#x27;].includes(route.path)&quot; active-color=&quot;#1989fa&quot; inactive-color=&quot;#000&quot; placeholder &gt; &lt;van-tabbar-item replace to=&quot;/home&quot; icon=&quot;home-o&quot;&gt; 首页 &lt;/van-tabbar-item&gt; &lt;!-- 这里的`dot`红点通过判断是否有新更新的通知来控制 --&gt; &lt;van-tabbar-item replace to=&quot;/notice&quot; icon=&quot;chat-o&quot; :dot=&quot;false&quot;&gt; 通知 &lt;/van-tabbar-item&gt; &lt;van-tabbar-item replace to=&quot;/user&quot; icon=&quot;user-o&quot;&gt; 个人中心 &lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.van-tabbar-item &#123; background-color: rgb(255, 255, 255);&#125;&lt;/style&gt; 首页123456789101112131415161718192021&lt;script setup lang=&quot;ts&quot;&gt;// 定义一个响应式的文本变量，需要通过后端来控制文本内容，组件挂载（onMounted）时axios发请求const notification = ref&lt;string&gt;(&#x27;内容待管理员更新...&#x27;)&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;home-layout&quot;&gt; &lt;!-- 轮播图 --&gt; &lt;HomeSwipe /&gt; &lt;!-- 小公告 --&gt; &lt;HomeNoticeBar :notification=&quot;notification&quot; /&gt; &lt;!-- 队徽队名 --&gt; &lt;HomeTeamName /&gt; &lt;!-- 功能表 --&gt; &lt;HomeGrid /&gt; &lt;!-- 底线 --&gt; &lt;Divider dividerText=&quot;暂时没有更多功能&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 首页-轮播图 图片更新需要改成后端更新图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* components/HomeSwipe/index.vue */&lt;script setup lang=&quot;ts&quot;&gt;// 需要改成后端调用更新图片const SwipeImages = reactive([ &#123; imgUrl: &#x27;https://olrando.oss-cn-chengdu.aliyuncs.com/img/duiqi.jpg&#x27;, index: 0 &#125;, &#123; imgUrl: &#x27;https://olrando.oss-cn-chengdu.aliyuncs.com/img/1681282717068.jpeg&#x27;, index: 1 &#125;, &#123; imgUrl: &#x27;https://olrando.oss-cn-chengdu.aliyuncs.com/img/1681282717071.jpeg&#x27;, index: 2 &#125;, &#123; imgUrl: &#x27;https://olrando.oss-cn-chengdu.aliyuncs.com/img/1681282717075.jpeg&#x27;, index: 3 &#125;])&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;swipe-container&quot;&gt; &lt;!-- 轮播图上层部分 --&gt; &lt;div class=&quot;foreground&quot;&gt; &lt;van-swipe loop class=&quot;my-swipe-fore&quot; :autoplay=&quot;3000&quot; indicator-color=&quot;#1989fa&quot; :touchable=&quot;false&quot; &gt; &lt;van-swipe-item v-for=&quot;item in SwipeImages&quot; :key=&quot;item.index&quot;&gt; &lt;img :src=&quot;item.imgUrl&quot; /&gt; &lt;/van-swipe-item&gt; &lt;/van-swipe&gt; &lt;/div&gt; &lt;!-- 轮播图下层部分 --&gt; &lt;div class=&quot;background&quot;&gt; &lt;van-swipe loop class=&quot;my-swipe-back&quot; :autoplay=&quot;3000&quot; :touchable=&quot;false&quot;&gt; &lt;van-swipe-item v-for=&quot;item in SwipeImages&quot; :key=&quot;item.index&quot;&gt; &lt;img :src=&quot;item.imgUrl&quot; /&gt; &lt;/van-swipe-item&gt; &lt;/van-swipe&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.swipe-container &#123; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; border-radius: 20px 20px 20px 20px;&#125;.foreground &#123; z-index: 1;&#125;.my-swipe-fore &#123; border-radius: 20px 20px 20px 20px; height: 210px; width: 330px; margin: 20px 0px 20px 0px; box-shadow: 2px 2px 20px #3b2e32; border: transparent;&#125;.my-swipe-fore .van-swipe-item img &#123; width: 100%; height: 100%; border-radius: 20px 20px 20px 20px;&#125;.background &#123; z-index: 0; filter: blur(4px); opacity: 0.8; position: absolute;&#125;.my-swipe-back &#123; border-radius: 20px 20px 20px 20px; height: 240px; width: 365px;&#125;.my-swipe-back .van-swipe-item img &#123; width: 100%; height: 100%; border-radius: 20px 20px 20px 20px;&#125;&lt;/style&gt; 首页-小通知12345678910111213141516171819202122/* components/HomeNoticeBar/index.vue */&lt;script setup lang=&quot;ts&quot;&gt;// 使用类型声明来定义 Props 类型interface Props &#123; text?: string // 让 text 成为可选的&#125;// 使用 defineProps 来定义组件的 PropsdefineProps&lt;Props&gt;()&lt;/script&gt;&lt;template&gt; &lt;van-notice-bar scrollable left-icon=&quot;volume-o&quot; color=&quot;#1989fa&quot; background=&quot;#ecf9ff&quot; :text=&quot;text || &#x27;暂时没有公告哦~&#x27;&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 首页-队徽队名1234567891011121314151617181920212223/* components/HomeTeamName/index.vue */&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;TeamName&quot;&gt; &lt;img src=&quot;@/assets/images/透明队徽.png&quot; alt=&quot;&quot; /&gt; &lt;h3&gt;&quot;小红帽&quot;常青藤青年志愿者服务队&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.TeamName &#123; display: flex; align-items: center; justify-content: center; margin: 5px 0;&#125;.TeamName img &#123; width: 30px; height: 30px;&#125;&lt;/style&gt; 首页-宫格123456789101112131415161718192021222324252627282930313233343536373839404142434445/* components/HomeGrid/index.vue */&lt;template&gt; &lt;van-grid icon-size=&quot;30px&quot; :column-num=&quot;2&quot; clickable&gt; &lt;van-grid-item text=&quot;校园服务通&quot; icon=&quot; icon-campus-service&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/campusservice&quot; /&gt; &lt;van-grid-item text=&quot;爱心雨伞&quot; icon=&quot; icon-love-umbrella&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/loveumbrella&quot; /&gt; &lt;van-grid-item text=&quot;服务队活动风采&quot; icon=&quot; icon-great-activities&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/activities&quot; /&gt; &lt;van-grid-item text=&quot;志愿活动报名&quot; icon=&quot; icon-signup-activities&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/signup&quot; /&gt; &lt;van-grid-item text=&quot;关于青队&quot; icon=&quot; icon-about-us&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/aboutus&quot; /&gt; &lt;van-grid-item text=&quot;用户意见反馈&quot; icon=&quot; icon-feedback&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/feedback&quot; /&gt; &lt;/van-grid&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 底线1234567891011121314151617181920212223/* components/Divider/index.vue */&lt;script setup lang=&quot;ts&quot;&gt;// 使用类型声明来定义 Props 类型interface Props &#123; dividerText?: string // 让 dividerText 成为可选的&#125;// 使用 defineProps 来定义组件的 PropsdefineProps&lt;Props&gt;()&lt;/script&gt;&lt;template&gt; &lt;van-divider class=&quot;divider&quot;&gt; &#123;&#123; dividerText &#125;&#125; &lt;/van-divider&gt;&lt;/template&gt;&lt;style scoped&gt;.divider &#123; margin: 20px 0px 20px 0px; padding: 0px 10px 0px 10px;&#125;&lt;/style&gt; 用户问题反馈页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;script setup lang=&quot;ts&quot;&gt;// 通知消息const notification = ref&lt;string&gt;( &#x27;为了更好地提升我们的服务质量，我们诚挚邀请您提供宝贵的意见和建议&#x27;)// 表单数据const isAnonymous = ref&lt;boolean&gt;(false) // 控制是否匿名const username = ref&lt;string&gt;(&#x27;&#x27;)const phone = ref&lt;string&gt;(&#x27;&#x27;)const studentId = ref&lt;string&gt;(&#x27;&#x27;)const message = ref&lt;string&gt;(&#x27;&#x27;)// 验证规则const rules = &#123; username: [ &#123; required: !isAnonymous.value, message: &#x27;姓名不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125; ], phone: [ &#123; required: false &#125;, &#123; pattern: /^1[3-9]\\d&#123;9&#125;$/, message: &#x27;手机号格式错误&#x27;, trigger: &#x27;onBlur&#x27; &#125; ], studentId: [ &#123; required: !isAnonymous.value, message: &#x27;学号不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;, &#123; pattern: /^\\d&#123;8,12&#125;$/, message: &#x27;学号格式不正确&#x27;, trigger: &#x27;onBlur&#x27; &#125; // 学号假设为8到12位数字 ], message: [&#123; required: true, message: &#x27;反馈内容不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;]&#125;// 提交处理const onSubmit = () =&gt; &#123; // 提交表单逻辑 if (isAnonymous.value) &#123; console.log(&#x27;匿名提交反馈&#x27;) &#125; else &#123; console.log(&#x27;实名提交反馈&#x27;) &#125; showToast(&#x27;提交成功&#x27;)&#125;// 监听匿名开关状态变化，实时更新验证规则watch(isAnonymous, (newVal) =&gt; &#123; rules.username[0].required = !newVal rules.studentId[0].required = !newVal&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 小公告 --&gt; &lt;HomeNoticeBar :notification=&quot;notification&quot; /&gt; &lt;!-- 队徽队名 --&gt; &lt;HomeTeamName /&gt; &lt;van-form @submit=&quot;onSubmit&quot;&gt; &lt;van-cell-group inset&gt; &lt;!-- 姓名 --&gt; &lt;van-field v-model=&quot;username&quot; :rules=&quot;rules.username&quot; :required=&quot;rules.username[0].required&quot; label=&quot;姓名&quot; placeholder=&quot;请输入您的姓名&quot; v-if=&quot;!isAnonymous&quot; /&gt; &lt;!-- 学号 --&gt; &lt;van-field v-model=&quot;studentId&quot; :rules=&quot;rules.studentId&quot; :required=&quot;rules.studentId[0].required&quot; label=&quot;学号&quot; placeholder=&quot;请输入您的学号&quot; v-if=&quot;!isAnonymous&quot; /&gt; &lt;!-- 手机号 --&gt; &lt;van-field v-model=&quot;phone&quot; :rules=&quot;rules.phone&quot; :required=&quot;rules.phone[0].required&quot; label=&quot;手机号&quot; placeholder=&quot;请输入您的手机号&quot; v-if=&quot;!isAnonymous&quot; /&gt; &lt;!-- 反馈内容 --&gt; &lt;van-field v-model=&quot;message&quot; :rules=&quot;rules.message&quot; :required=&quot;rules.message[0].required&quot; rows=&quot;2&quot; autosize label=&quot;反馈内容&quot; type=&quot;textarea&quot; maxlength=&quot;1000&quot; placeholder=&quot;请输入反馈内容&quot; show-word-limit /&gt; &lt;van-field name=&quot;switch&quot; label=&quot;匿名提交&quot;&gt; &lt;template #input&gt; &lt;van-switch v-model=&quot;isAnonymous&quot; /&gt; &lt;/template&gt; &lt;/van-field&gt; &lt;/van-cell-group&gt; &lt;div style=&quot;margin: 16px&quot;&gt; &lt;van-button round block type=&quot;primary&quot; native-type=&quot;submit&quot;&gt; 提交 &lt;/van-button&gt; &lt;/div&gt; &lt;/van-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 个人资料页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;script setup lang=&quot;ts&quot;&gt;// 用户的个人信息const userInfo = ref(&#123; avatar: &#x27;&#x27;, // 用户头像 username: &#x27;用户名&#x27;, realName: &#x27;张三&#x27;, // 真实姓名，不能修改 studentId: &#x27;20230001&#x27;, // 学号，不能修改 phone: &#x27;12345678901&#x27;, email: &#x27;example@example.com&#x27;, bio: &#x27;这是我的个人简介。&#x27;, gender: 0 // 性别：0 = 不填写，1 = 男，2 = 女&#125;)const isEditing = ref(false) // 标记是否处于编辑模式// 进入编辑模式const startEditing = () =&gt; &#123; isEditing.value = true&#125;// 提交修改const saveChanges = () =&gt; &#123; isEditing.value = false&#125;// 上传头像const uploadAvatar = (e: Event) =&gt; &#123; const file = (e.target as HTMLInputElement).files?.[0] if (file) &#123; userInfo.value.avatar = URL.createObjectURL(file) showToast(&#x27;头像上传成功&#x27;) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;van-nav-bar title=&quot;个人资料&quot; fixed placeholder /&gt; &lt;!-- 头像部分 --&gt; &lt;div style=&quot;text-align: center; margin: 20px 0&quot;&gt; &lt;label for=&quot;avatar-upload&quot; style=&quot;cursor: pointer&quot;&gt; &lt;img :src=&quot;userInfo.avatar || &#x27;https://via.placeholder.com/80&#x27;&quot; alt=&quot;avatar&quot; style=&quot;width: 80px; height: 80px; border-radius: 50%&quot; /&gt; &lt;/label&gt; &lt;!-- 当处于编辑模式时才显示提示 --&gt; &lt;p v-if=&quot;isEditing&quot;&gt;点击头像修改&lt;/p&gt; &lt;input :disabled=&quot;!isEditing&quot; id=&quot;avatar-upload&quot; type=&quot;file&quot; accept=&quot;image/*&quot; style=&quot;display: none&quot; @change=&quot;uploadAvatar&quot; /&gt; &lt;/div&gt; &lt;!-- 个人信息部分 --&gt; &lt;van-cell-group&gt; &lt;!-- 用户名 --&gt; &lt;van-field v-model=&quot;userInfo.username&quot; label=&quot;用户名&quot; :disabled=&quot;!isEditing&quot; :input-align=&quot;&#x27;left&#x27;&quot; /&gt; &lt;!-- 真实姓名（不可修改） --&gt; &lt;van-field v-model=&quot;userInfo.realName&quot; label=&quot;真实姓名&quot; :disabled=&quot;true&quot; :input-align=&quot;&#x27;left&#x27;&quot; :class=&quot;isEditing ? &#x27;disabled-field&#x27; : &#x27;&#x27;&quot; /&gt; &lt;!-- 学号（不可修改） --&gt; &lt;van-field v-model=&quot;userInfo.studentId&quot; label=&quot;学号&quot; :disabled=&quot;true&quot; :input-align=&quot;&#x27;left&#x27;&quot; :class=&quot;isEditing ? &#x27;disabled-field&#x27; : &#x27;&#x27;&quot; /&gt; &lt;!-- 手机号 --&gt; &lt;van-field v-model=&quot;userInfo.phone&quot; label=&quot;手机号&quot; :disabled=&quot;!isEditing&quot; :input-align=&quot;&#x27;left&#x27;&quot; /&gt; &lt;!-- 邮箱 --&gt; &lt;van-field v-model=&quot;userInfo.email&quot; label=&quot;邮箱&quot; :disabled=&quot;!isEditing&quot; :input-align=&quot;&#x27;left&#x27;&quot; /&gt; &lt;!-- 性别 --&gt; &lt;van-field label=&quot;性别&quot; :disabled=&quot;!isEditing&quot; :input-align=&quot;&#x27;left&#x27;&quot;&gt; &lt;template #input&gt; &lt;van-radio-group :disabled=&quot;!isEditing&quot; v-model=&quot;userInfo.gender&quot; direction=&quot;horizontal&quot; &gt; &lt;van-radio name=&quot;1&quot;&gt;男&lt;/van-radio&gt; &lt;van-radio name=&quot;2&quot;&gt;女&lt;/van-radio&gt; &lt;van-radio name=&quot;0&quot;&gt;保密&lt;/van-radio&gt; &lt;/van-radio-group&gt; &lt;/template&gt; &lt;/van-field&gt; &lt;!-- 个人简介 --&gt; &lt;van-field v-model=&quot;userInfo.bio&quot; label=&quot;个人简介&quot; type=&quot;textarea&quot; rows=&quot;3&quot; :autosize=&quot;&#123; maxHeight: 100 &#125;&quot; maxlength=&quot;150&quot; placeholder=&quot;请输入个人简介&quot; show-word-limit :disabled=&quot;!isEditing&quot; /&gt; &lt;/van-cell-group&gt; &lt;!-- 编辑按钮 --&gt; &lt;div style=&quot;margin: 16px&quot;&gt; &lt;van-button v-if=&quot;!isEditing&quot; type=&quot;primary&quot; block @click=&quot;startEditing&quot;&gt; 修改个人信息 &lt;/van-button&gt; &lt;van-button v-else type=&quot;success&quot; block @click=&quot;saveChanges&quot;&gt; 保存修改 &lt;/van-button&gt; &lt;/div&gt; &lt;Divider dividerText=&quot;人工智能学院 “小红帽”常青藤青年志愿者服务队&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.disabled-field input &#123; background-color: #f5f5f5; color: #aaa;&#125;&lt;/style&gt; 权限申请页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;script setup lang=&quot;ts&quot;&gt;// 通知消息const notification = ref&lt;string&gt;( &#x27;目前只支持青队成员可以申请权限哦~后续也会为普通用户提供权限福利！&#x27;)// 表单数据const username = ref&lt;string&gt;(&#x27;&#x27;)const studentId = ref&lt;string&gt;(&#x27;&#x27;)const reson = ref&lt;string&gt;(&#x27;&#x27;)const right = ref(&#x27;&#x27;)const showPicker = ref(false)const right_columns = [ &#123; text: &#x27;超级管理员&#x27;, value: &#x27;1&#x27; &#125;, &#123; text: &#x27;管理员&#x27;, value: &#x27;2&#x27; &#125;]const onConfirm = (&#123; selectedOptions &#125;) =&gt; &#123; right.value = selectedOptions[0]?.text showPicker.value = false&#125;// 验证规则const rules = &#123; username: [&#123; required: true, message: &#x27;姓名不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;], studentId: [ &#123; required: true, message: &#x27;学号不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;, &#123; pattern: /^\\d&#123;8,12&#125;$/, message: &#x27;学号格式不正确&#x27;, trigger: &#x27;onBlur&#x27; &#125; // 学号假设为8到12位数字 ], right: [&#123; required: true, message: &#x27;请选择要申请的权限&#x27;, trigger: &#x27;onBlur&#x27; &#125;], reson: [&#123; required: true, message: &#x27;申请原因不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;]&#125;// 提交处理const onSubmit = () =&gt; &#123; showToast(&#x27;提交成功&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 小公告 --&gt; &lt;HomeNoticeBar :notification=&quot;notification&quot; /&gt; &lt;!-- 队徽队名 --&gt; &lt;HomeTeamName /&gt; &lt;van-form @submit=&quot;onSubmit&quot;&gt; &lt;van-cell-group inset&gt; &lt;!-- 姓名 --&gt; &lt;van-field v-model=&quot;username&quot; :rules=&quot;rules.username&quot; :required=&quot;rules.username[0].required&quot; label=&quot;姓名&quot; placeholder=&quot;请输入您的姓名&quot; /&gt; &lt;!-- 学号 --&gt; &lt;van-field v-model=&quot;studentId&quot; :rules=&quot;rules.studentId&quot; :required=&quot;rules.studentId[0].required&quot; label=&quot;学号&quot; placeholder=&quot;请输入您的学号&quot; /&gt; &lt;!-- 申请权限 --&gt; &lt;van-field v-model=&quot;right&quot; :rules=&quot;rules.right&quot; :required=&quot;rules.right[0].required&quot; is-link readonly name=&quot;picker&quot; label=&quot;选择器&quot; placeholder=&quot;点击选择权限&quot; @click=&quot;showPicker = true&quot; /&gt; &lt;van-popup v-model:show=&quot;showPicker&quot; position=&quot;top&quot;&gt; &lt;van-picker :columns=&quot;right_columns&quot; @confirm=&quot;onConfirm&quot; @cancel=&quot;showPicker = false&quot; /&gt; &lt;/van-popup&gt; &lt;!-- 申请原因 --&gt; &lt;van-field v-model=&quot;reson&quot; :rules=&quot;rules.reson&quot; :required=&quot;rules.reson[0].required&quot; rows=&quot;2&quot; autosize label=&quot;申请原因&quot; type=&quot;textarea&quot; maxlength=&quot;1000&quot; placeholder=&quot;请输入申请原因&quot; show-word-limit /&gt; &lt;/van-cell-group&gt; &lt;div style=&quot;margin: 16px&quot;&gt; &lt;van-button round block type=&quot;primary&quot; native-type=&quot;submit&quot;&gt; 提交 &lt;/van-button&gt; &lt;/div&gt; &lt;/van-form&gt; &lt;Divider dividerText=&quot;人工智能学院 “小红帽”常青藤青年志愿者服务队&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 使用指南页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;script setup lang=&quot;ts&quot;&gt;const activeName = ref&lt;string&gt;(&#x27;1&#x27;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;van-nav-bar title=&quot;使用指南&quot; fixed placeholder /&gt; &lt;van-collapse v-model=&quot;activeName&quot; accordion&gt; &lt;!-- 登录账户指南 --&gt; &lt;van-collapse-item title=&quot;步骤 1: 登录账户&quot; name=&quot;1&quot; :title-style=&quot;&#123; color: activeName === &#x27;1&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 使用注册时的手机号或邮箱进行登录，未注册用户请先注册。登录后可以访问所有功能。 &lt;/van-collapse-item&gt; &lt;!-- 查看通知指南 --&gt; &lt;van-collapse-item title=&quot;步骤 2: 查看通知&quot; name=&quot;2&quot; :title-style=&quot;&#123; color: activeName === &#x27;2&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 登录后可以在通知页面查看最新的公告和通知，保持信息的及时获取。 &lt;/van-collapse-item&gt; &lt;!-- 提交反馈指南 --&gt; &lt;van-collapse-item title=&quot;步骤 3: 提交反馈&quot; name=&quot;3&quot; :title-style=&quot;&#123; color: activeName === &#x27;3&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 在反馈页面填写您的意见和建议，支持匿名提交，帮助我们改进服务。 &lt;/van-collapse-item&gt; &lt;!-- 修改个人信息指南 --&gt; &lt;van-collapse-item title=&quot;步骤 4: 修改个人信息&quot; name=&quot;4&quot; :title-style=&quot;&#123; color: activeName === &#x27;4&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 您可以在个人中心修改头像、昵称和联系方式等信息，以确保个人资料的准确性。 &lt;/van-collapse-item&gt; &lt;!-- 常见问题指南 --&gt; &lt;van-collapse-item title=&quot;常见问题&quot; name=&quot;5&quot; :title-style=&quot;&#123; color: activeName === &#x27;5&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 在常见问题页面，我们整理了一些常见的使用疑问及解答，供您参考。 &lt;/van-collapse-item&gt; &lt;!-- 联系客服指南 --&gt; &lt;van-collapse-item title=&quot;联系客服&quot; name=&quot;6&quot; :title-style=&quot;&#123; color: activeName === &#x27;6&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 如果遇到问题无法解决，您可以通过联系客服功能与我们取得联系。 &lt;/van-collapse-item&gt; &lt;/van-collapse&gt; &lt;Divider dividerText=&quot;人工智能学院 “小红帽”常青藤青年志愿者服务队&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 设置页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;script setup lang=&quot;ts&quot;&gt;const router = useRouter()// 退出登录函数const logout = () =&gt; &#123; // 模拟退出登录逻辑，可以在这里处理实际的退出登录操作 showSuccessToast(&#123; message: &#x27;已退出登录&#x27;, position: &#x27;top&#x27; &#125;) router.push(&#x27;/&#x27;)&#125;// 处理其他设置项点击事件const handleSettingClick = (message: string) =&gt; &#123; showToast(&#123; message: message, position: &#x27;top&#x27; &#125;)&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;van-nav-bar title=&quot;设置&quot; fixed placeholder /&gt; &lt;!-- 设置选项 --&gt; &lt;van-cell-group&gt; &lt;!-- 修改密码 --&gt; &lt;van-cell title=&quot;修改密码&quot; is-link @click=&quot;handleSettingClick(&#x27;修改密码功能正在开发中...&#x27;)&quot; /&gt; &lt;!-- 通知设置 --&gt; &lt;van-cell title=&quot;通知设置&quot; is-link @click=&quot;handleSettingClick(&#x27;通知设置功能正在开发中...&#x27;)&quot; /&gt; &lt;!-- 隐私设置 --&gt; &lt;van-cell title=&quot;隐私设置&quot; is-link @click=&quot;handleSettingClick(&#x27;隐私设置功能正在开发中...&#x27;)&quot; /&gt; &lt;/van-cell-group&gt; &lt;!-- 退出登录按钮 --&gt; &lt;div style=&quot;margin: 16px&quot;&gt; &lt;van-button type=&quot;danger&quot; block @click=&quot;logout&quot;&gt; 退出登录 &lt;/van-button&gt; &lt;/div&gt; &lt;Divider dividerText=&quot;人工智能学院 “小红帽”常青藤青年志愿者服务队&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 问题解决导入vue文件TS报错错误信息提示： TypeScript 无法找到模块 @/views/**/**.vue 的声明文件，这意味着 TypeScript 无法推断该文件的类型，因此默认将其视为 any 类型。 原因：TypeScript 默认不支持 .vue 文件的模块类型解析，需要手动添加类型声明文件。 解决方法： 12345678/* env.d.ts *//// &lt;reference types=&quot;vite/client&quot; /&gt;declare module &#x27;*.vue&#x27; &#123; import type &#123; DefineComponent &#125; from &#x27;vue&#x27; // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types const component: DefineComponent&lt;&#123;&#125;, &#123;&#125;, any&gt; export default component&#125;","categories":[],"tags":[]},{"title":"","slug":"暑假学习","date":"2024-08-02T06:22:19.784Z","updated":"2024-09-29T13:24:25.924Z","comments":true,"path":"2024/08/02/暑假学习/","permalink":"http://eastyn7.github.io/2024/08/02/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"title：暑假学习TypeScriptJS已有的类型 原始类型：number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol 对象类型：object（数组、对象、函数等对象） TS新增的类型 联合类型、自定义类型（类型别名）、接口、元祖、字面量类型、枚举、void、any等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 原始类型let age: number = 18let myName: string = &#x27;eee&#x27;let isLoading: boolean = truelet a: null = nulllet b: undefined = undefinedlet s: symbol = Symbol()// 对象类型let numbers: number[] = [1,2,3]let strings: string[] = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]let strings: Array&lt;string&gt; = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]// 联合类型let arr: (number | string)[] = [&#x27;1&#x27;,1,&#x27;2&#x27;,2,&#x27;3&#x27;,3]// 类型别名type CustomArray = (number | string)[]let arr1: CustomArray = [&#x27;1&#x27;,1,&#x27;2&#x27;,2,&#x27;3&#x27;,3]// 函数类型function add(num1: number, num2: number): number &#123; return num1 + num2&#125;const add = (num1: number, num2: number): number =&gt; &#123; return num1 + num2&#125;const add: (num1: number, num2: number) =&gt; number = (num1, num2) =&gt; &#123; return num1 + num2&#125;function greet(name: string): void &#123; console.log(&#x27;Hello&#x27;, name)&#125;// 可选参数function mySlice(start?: number, end?: number): void &#123; console.log(&#x27;起始索引：&#x27;, start, &#x27;结束索引：&#x27;, end)&#125;// 对象类型let person: &#123; name: string; age: number; &#125;// 接口interface IPerson &#123; name: string age: number sayHi(): void&#125;let person: IPerson = &#123; name: &#x27;Jack&#x27;, age: 19, sayHi() &#123;&#125;&#125;/*接口与类型别名的对比：相同点：都可以给对象指定类型不同点：接口只能为对象指定类型；类型别名不仅可以为对象指定类型，实际上可以为任意类型指定别名*/type IPerson = &#123; name: string age: number sayHi(): void&#125;type NumStr = number |string// 接口的继承interface Point2D &#123; x: number; y: number &#125;interface Point3D extends Point2D &#123; z: number &#125;// 元组let position: [number, number] = [0.11, 0.22]// 类型断言const aLink: HTMLAnchorElementconst aLink = document.getElementByID(&#x27;link&#x27;) as HTMLAnchorElement// const aLink = &lt;HTMLAnchorElement&gt;document.getELementById(&#x27;link&#x27;)【不常用，跟react有冲突】// 字面量类型let str1 = &#x27;Hello TS&#x27; // string；let声明变量const str2 = &#x27;Hello TS&#x27; // &quot;Hello TS&quot;；const声明常量// 用来表示一组明确的可选值列表function changeDirection(directin: &#x27;up&#x27; | &#x27;down&#x27; | &#x27;left&#x27; | &#x27;right&#x27;)&#123; console.log(direction)&#125;// 枚举(enum)enum Direction &#123; Up, Down, Left, Right &#125;function changeDirection(directin: Direction)&#123; console.log(direction)&#125;changeDirection(Direction.Left)/*枚举成员的值默认第一个为0依次增加，也可以自定义值【默认数字，也可以为字符串】enum Direction &#123; Up = 10, Down, Left, Right &#125;enum Direction &#123; Up = 2, Down = 4, Left = 8, Right = 16 &#125;*/// 字符串枚举enum Direction &#123; Up = &#x27;UP&#x27;, Down = &#x27;DOWN&#x27;, Left = &#x27;LEFT&#x27;, Right = &#x27;RIGHT&#x27; &#125;// any类型let obj: any = &#123; x: 0 &#125;// typeofconsole.log(typeof &quot;Hello world&quot;)// 根据类型上下文来let p = &#123; x: 1, y: 2 &#125;function formatPoint(point: &#123; x: number; y: number&#125;)&#123;&#125;formatPoint(p)function formatPoint(point: typeof p) TS高级类型 class类、类型兼容性、交叉类型、泛型和keyof、索引签名类型和索引查询类型、映射类型等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// class类class Person&#123; age: number // gender: &#x27;男&#x27; gender: string x = 10 y = 10 // 构造函数 constructor(age: number, gender: string)&#123; this.age = age this.gender = gender &#125; // 实例方法 scale(n: number): void &#123; this.x *= n this.y *= n &#125;&#125;const p = new Person()p.age// 类继承class Animal &#123; move() &#123; console.log(&#x27;Moving along!&#x27;) &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log(&#x27;wang!&#x27;) &#125;&#125;const dog = new Dog()// 接口interface Singable &#123; sing(): void&#125;class Person implements Singable &#123; sing() &#123; console.log(&#x27;asdfadf&#x27;) &#125;&#125;// 修饰符publicprotectedprivatereadonly：表示只读，只能被构造函数进行赋值// 类型兼容性对象兼容：成员多的赋值给成员少的接口兼容：多的赋值给少的函数兼容：参数个数少的赋值给参数个数多的；参数类型对应一致；返回值多的赋值给少的// 交叉类型（&amp;）interface Person &#123; name: string &#125;interface Contact &#123; phone: string &#125;type PersonDetail = Person &amp; Contactlet obj = PersonDetail = &#123; name: &#x27;Jack&#x27;, phone: &#x27;123...&#x27;&#125;/*交叉类型和接口继承的对比相同点：都可以实现对象类型的组合不同点：两种方式实现类型组合时，对于同名属性之间，处理类型冲突的方式不同。继承会报错但是交叉类型不会interface A &#123; fn: (value: number) =&gt; string&#125;interface B extends A &#123; fn: (value: string) =&gt; string&#125;这里是错误的interface A &#123; fn: (value: number) =&gt; string&#125;interface B &#123; fn: (value: string) =&gt; string&#125;type C = A &amp; B 相当于 在C中fn: (value: string | number) =&gt; string*/// 泛型function id&lt;Type&gt;(value: Type): Type &#123; return value &#125;const num = id&lt;number&gt;(10) // 此时num的类型即为numberconst str = id&lt;string&gt;(&#x27;str&#x27;) // 此时str的类型即为stringlet num = id(10) // 可以简化不用写&lt;&gt;，会推断为字面量类型// 泛型约束/*指定更加具体的类型*/function id&lt;Type&gt;(value: Type[]): Type[] &#123; console.log(value.length) return value&#125;/*添加约束*//*只要有length属性就可以*/interface ILength &#123; length: number &#125;function id&lt;Type extedns ILength&gt;(value: Type): Type &#123; console.log(value.length) return value&#125;// 多个泛型变量的情况function getProp&lt;Type, Key extends keyof Type&gt;(obj: Type, key: Key)&#123; return obj[key]&#125;let person = &#123; name: &#x27;Jack&#x27;, age: 18 &#125;getProp(person, &#x27;name&#x27;)// 泛型接口interface IdFunc&lt;Type&gt; &#123; id: (value: Type) =&gt; Type ids: () =&gt; Type[]&#125;let obj: IdFunc&lt;number&gt; &#123; id(value) &#123; return value &#125;, ids() &#123; return [1, 3, 5] &#125;&#125;// 泛型类class GenericNumber&lt;NumType&gt; &#123; defaultValue: NumType add: (x: NumType, y: NumType) =&gt; NumType&#125;const myNum = new GenericNumber&lt;number&gt;()// 泛型工具类型（Partial）/*构造出来的新类型PartialProps结构和Props相同，但所有属性都变为是可选的*/interface Props &#123; id: string children: number[]&#125;type PartialProps = Partial&lt;Props&gt;// 泛型工具类型（Readonly）/*构造一个所有属性为只读的类型*/interface Props &#123; id: string children: number[]&#125;type ReadonlyProps = Readonly&lt;Props&gt;// 泛型工具类型（Pick）/*Pick&lt;Type,Keys&gt;从Type中选择一组属性来构造新类型*/interface Props &#123; id: string title: string children: number[]&#125;type PickProps = Pick&lt;Props, &#x27;id&#x27; | &#x27;title&#x27;&gt;// 泛型工具类型（Record）/*Record&lt;Keys,Type&gt;构造一个新对象类型，属性键为Keys，属性类型为Type*/type RecordObj = Record&lt;&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;, string[]&gt;let obj: RecordObj = &#123; a: [&#x27;1&#x27;], b: [&#x27;2&#x27;], c: [&#x27;3&#x27;]&#125;// 索引签名类型interface AnyObject &#123; [key: steing]: number&#125;let obj: AnyObject = &#123; a: 1, b: 2&#125; // 映射类型/*基于旧类型创建新类型，只能在类型别名中使用*/type PropKeys = &#x27;x&#x27; | &#x27;y&#x27; | &#x27;z&#x27;type Type = &#123; [Key in PropKeys]: number &#125;type Props = &#123; a: number; b: string; c: boolean &#125;type Type = &#123; [Key in keyof Props]: number &#125;// 索引查询类型/*T[P]语法用来查询属性的类型*/type Props = &#123; a: number; b: string; c: boolean &#125;type TypeA = Props[&#x27;a&#x27;]//numbertype TypeA = Props[&#x27;a&#x27; | &#x27;b&#x27;]//number|stringtype TypeA = Props[keyof Props]//number|string|boolean TS中的文件类型 .ts文件 既包含类型信息又可执行代码 可以被编译为.js文件然后执行 用途：编写程序代码的地方 .d.ts文件（类似于C++中的头文件） 只包含类型信息的类型声明文件 不会生成.js文件，仅用于提供类型信息 用途：为js提供类型信息 //为js文件提供类型声明 /* 在js文件中已存在如下的内容 let count = 10 let songName = &#39;痴心绝对&#39; let position = &#123; x: 0, y: 0 &#125; function add(x,y) &#123; retrun x+y &#125; function changeDirection(direction)&#123; console.log(direction) &#125; const fomartPoint = point =&gt; &#123; console.log(&#39;当前坐标:&#39;, point) &#125; export &#123;count, songName, position, add, changeDirection&#125; */ declare let count: number declare let someName: string interface Point &#123; x: number y: number &#125; declare let positon: Point declare function add(x: mumber, y: number): number declare function changeDirection(direction: &#39;up&#39;|&#39;down&#39;|&#39;left&#39;|&#39;right&#39;):void type FomartPoint = (point: Point) =&gt; void declare const fomartPoint: FomartPoint // declare const fomartPoint: (point: Point) =&gt; void export &#123;count, songName, position, add, changeDirection&#125; SSMSpring1.Spring Framework系统架构 Core Container : 核心容器 AOP : 面向切面编程 Aspects : AOP思想实现 Data Access : 数据访问 Data Integration : 数据集成 Web : Web开发 Test : 单元测试与集成测试 IoC（Inversion of Control）控制反转：使用对象事，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转 Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的“外部” IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean DI（Dependency Injection）依赖注入：在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入 2.bean 类别 描述 名称 bean 类型 标签 所属 beans标签 格式 属性列表 id：bean的id，使用容器可以通过id值获取对应的bean，在一个容器中id值唯一class：bean的类型，即配置的bean的全路径类名name：bean的别名，可以有多名称，空格分开scope：bean的作用范围，可以控制创建实例的数量，是否是单例的对象，可选范围【singleton（单例默认）、prototype（非单例）】init-method：bean初始化方法destroy-method：bean的销毁方法 范例 实例化 构造函数：使用静态工厂：使用实例工厂： 生命周期 阶段：1、初始化容器：①创建对象（内存分配）②执行构造方法③执行属性注入（set操作）④执行bean初始化方法2、使用bean：①执行业务操作3、关闭&#x2F;销毁容器：①执行bean销毁方法pbulic class BookDaoImpl implements BookDao { &#x2F;&#x2F; 表示bean初始化对应的操作 public void init(){ System.out.println(“init…”) } &#x2F;&#x2F; 表示bean销毁前对应的操作 【 需要关闭容器： ①手工关闭容器：ConfigurableApplicationContext接口close()操作 ②注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机：ConfigurableApplicationContext接口registerShutdownHook()操作 】 public void destory{ System.out.println(“destory…”) }}&#x2F;&#x2F; 需要在配置文件中进行配置【也可以使用接口控制生命周期，InitializingBean，DisposableBean接口】 3.依赖注入 setter注入 构造器注入 自动装配： 方式：按类型（常用）、按名称、按构造方法、不启用自动装配 4.集合注入","categories":[],"tags":[]},{"title":"","slug":"express入门","date":"2024-02-22T08:30:19.690Z","updated":"2024-09-29T13:23:59.417Z","comments":true,"path":"2024/02/22/express入门/","permalink":"http://eastyn7.github.io/2024/02/22/express%E5%85%A5%E9%97%A8/","excerpt":"","text":"title：Express入门express入门简介作为前端开发，Nodejs已经成了很多公司对我们这一岗位的硬性要求，而 Express 框架则是其中知名度最高、也是最受欢迎的Nodejs开发框架，它帮助我们封装了Nodejs底层的API，屏蔽了大量的繁琐的细节，让我们只需要关注业务开发就行了，极大的降低了学习的成本。今天这个课程就是教大家去掌握如何使用express去搭建一个简易的后端服务，我们主要围绕以下几个部分： 路由 中间件 静态文件服务 模板引擎 环境准备 电脑 - mac Node - 16.14.2 Npm - 8.5.0 Express - 4.x 第一个demo使用Nodejs内置的http模块搭建服务为了便于大家去理解express对nodejs做了哪些封装，在使用express之前，我们先来看下使用nodejs内置的http模块是怎么搭建node服务的。 首先创建一个express-demo的文件夹并进入 1mkdir express-demo &amp;&amp; cd express-demo 创建server.js，并添加如下代码： 1234567891011const http = require(&#x27;http&#x27;)const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;) res.end(&#x27;hello world&#x27;)&#125;)server.listen(3000, () =&gt; &#123; console.log(&#x27;服务已启动...&#x27;);&#125;) 然后在控制台中运行： 1node server.js 使用express搭建服务接下来，我们再用express搭建服务。 在 express-demo 文件夹下执行 npm init 命令，然后一路回车，就会帮我们创建一个 package.json 文件，然后再执行 npm install express 来安装express模块，然后改写 server.js 。 1234567891011const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;hello world&#x27;)&#125;)app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已启动...&#x27;);&#125;) Request和Response对象 Request对象是请求对象，就是回调函数中的req参数，主要是网络请求中带的一些属性，比如参数, cookie等等。。。 Response对象是响应对象，就是回调函数中的res参数，可以执行一系列的响应操作，比如给客户端响应内容和状态等等。。。 查看Request和Response对象的所有API 路由机制思考：我们在向后端发请求时通过什么去区分接口的？ 答：请求方式+接口url 我们在express中，定义路由的方式是： 1app.METHOD(URL, CALLBACK) 这种方式就可以通过请求方式和URL来帮我们区分不同的请求，从而去执行不同的响应。 nodemonnodemon能够检测工作区代码的变化，并自动重启。 执行 npm install nodemon --save-dev 安装nodemon，然后修改package.json文件中的start命令： 123456789101112131415161718&#123; &quot;name&quot;: &quot;express-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;server.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;nodemon server.js&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.18.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;nodemon&quot;: &quot;^2.0.20&quot; &#125;&#125; 再执行npm start启动服务，之后我们再修改代码就不需要手动的重启服务了。 核心概念路由在浏览器中我们想要访问百度，只需要知道百度的地址就行了，路由也是类似的概念，我们想要知道客户端调用的是哪个接口，就是通过路由来判断的。 路由方法Express 支持对应于 HTTP 方法的以下路由方法：get、post、put、delete等等。使用方法为： 1app.METHOD(URL, CALLBACK) 示例： 1234567891011const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;hello world&#x27;)&#125;)app.post(&#x27;/about&#x27;, (req, res) =&gt; &#123; res.send(&#123; name: &#x27;小明&#x27;, age: 18 &#125;)&#125;) 有一种特殊路由方法：app.all()，该方法用于在所有请求方法的路径中装入中间件函数。 123456app.all(&#x27;/about&#x27;, function(req, res) &#123; res.send(&#123; name: &#x27;jackie&#x27;, age: 18 &#125;)&#125;) 这个示例中不管是get, post方式去请求/about路径的接口，都会经过这个回调函数然后返回对应的数据。 路由路径路由路径可以是字符串、字符串模式或正则表达式。字符串类型的就是我们之前举的那些例子，我们再来看下字符串模式和正则表达式这两种。 以下是基于字符串模式的路由路径的一些示例。 此路由路径将匹配 acd 和 abcd。 123app.get(&#x27;/ab?cd&#x27;, function(req, res) &#123; res.send(&#x27;ab?cd&#x27;);&#125;); 此路由路径将匹配 abcd、abbcd、abbbcd 等。 123app.get(&#x27;/ab+cd&#x27;, function(req, res) &#123; res.send(&#x27;ab+cd&#x27;);&#125;); 此路由路径将匹配 abcd、abxcd、abRABDOMcd、ab123cd 等。 123app.get(&#x27;/ab*cd&#x27;, function(req, res) &#123; res.send(&#x27;ab*cd&#x27;);&#125;); 基于正则表达式的路由路径的示例： 此路由路径将匹配名称中具有“a”的所有路由。 123app.get(/a/, function(req, res) &#123; res.send(&#x27;/a/&#x27;);&#125;); 此路由路径将匹配 butterfly 和 dragonfly，但是不匹配 butterflyman、dragonfly man 等。 123app.get(/.*fly$/, function(req, res) &#123; res.send(&#x27;/.*fly$/&#x27;);&#125;); 路由拆分当我们的路由越来越复杂，比如有用户相关的路径，有系统相关的路径，不统一管理的话会显得特别乱，这个时候，对路由进行拆分是个不错的选择。 拆分前 123456789101112const express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/user/list&#x27;, function(req, res, next)&#123; res.send(&#x27;/list&#x27;);&#125;);app.get(&#x27;/user/detail&#x27;, function(req, res, next)&#123; res.send(&#x27;/detail&#x27;);&#125;);app.listen(3000); 拆分后 12345678910111213141516const express = require(&#x27;express&#x27;);const app = express();const user = express.Router();user.get(&#x27;/list&#x27;, function(req, res, next)&#123; res.send(&#x27;/list&#x27;);&#125;);user.get(&#x27;/detail&#x27;, function(req, res, next)&#123; res.send(&#x27;/detail&#x27;);&#125;);app.use(&#x27;/user&#x27;, user); // 注册user子路由app.listen(3000); 中间件一般学习js的时候，我们都会听到一句话：一切皆函数。而在学习express的过程中，很深的一个感受就是：一切皆中间件。比如常见的请求参数解析、cookie解析、日志打印等，都可以通过中间件来完成。 在 Express 中，中间件就是一个函数： 1234function someMiddleware(req, res, next) &#123; // 自定义逻辑 next();&#125; 三个参数中，req 和 res 就是前面提到的 Request 请求对象和 Response 响应对象；而 next 函数则用来触发下一个中间件的执行。 在 Express 使用中间件有两种方式：全局中间件和路由中间件。 全局中间件通过 app.use 函数就可以注册中间件，并且此中间件会在用户发起任何请求都可能会执行，例如： 1app.use(someMiddleware) 路由中间件通过在路由定义时注册中间件，此中间件只会在用户访问该路由时执行，例如： 123app.get(&#x27;/middleware&#x27;, someMiddleware, (req, res) =&gt; &#123; res.send(&#x27;Hello World&#x27;);&#125;); 编写一个日志中间件 新建一个logger.js，并写入以下函数 1234567function logger(req, res, next) &#123; const time = new Date(); console.log(`[$&#123;time.toLocaleString()&#125;] $&#123;req.method&#125; $&#123;req.url&#125;`); next();&#125;module.exports = logger; 在server.js引入logger函数并且全局注册 123456const logger = require(&#x27;./logger&#x27;)......app.use(logger)...... 这样我们在访问路由后，每次都会在控制台打印一行日志，如下： 12[2023/2/27 15:54:29] GET /[2023/2/27 15:54:47] POST /about 注意：如果忘记在中间件中调用 next 函数，并且又不直接返回响应时，服务器会直接卡在这个中间件不会继续执行下去哦！ 模版引擎模版引擎可以简单的理解为升级版的html文档，express可以用模版引擎来渲染前端页面，模版引擎有很多种，包括jade, ejs, nunjunks, Handlebars等等，express对每一种都提供了很好的支持，只需要几行代码就可以使用。我们今天来学习下Handlebars。 首先，第一步是安装对应的模版引擎： 1npm install hbs 然后创建views文件夹，并且新建一个index.hbs的文件，添加如下内容： 123&lt;h1&gt;express入门课程&lt;/h1&gt;&lt;p&gt;作为前端开发，Nodejs已经成了很多公司对我们这一岗位的硬性要求，而 Express 框架则是其中知名度最高、也是最受欢迎的Nodejs开发框架。。。&lt;/p&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt; 然后再添加一个about.hbs的文件，并添加如下内容： 12&lt;h1&gt;黑马前端&lt;/h1&gt;&lt;p&gt;学前端，来黑马&lt;/p&gt; 最后便是在 server.js 中配置和使用模板。配置模板的代码非常简单： 12345// 指定模板存放目录app.set(&#x27;views&#x27;, &#x27;views&#x27;);// 指定模板引擎为 Handlebarsapp.set(&#x27;view engine&#x27;, &#x27;hbs&#x27;); 在使用模板时，只需在路由回调函数中调用 res.render 方法即可： 1234567891011121314151617// ...const app = express();app.set(&#x27;views&#x27;, &#x27;views&#x27;);app.set(&#x27;view engine&#x27;, &#x27;hbs&#x27;);app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; // 渲染index.hbs模版 res.render(&#x27;index&#x27;);&#125;);app.get(&#x27;/about&#x27;, (req, res) =&gt; &#123; // 渲染about.hbs模版 res.render(&#x27;about&#x27;);&#125;)// ... 当我们访问localhost:3000时就会加载对应的index.hbs这个模版，当我们访问localhost:3000/about时就会加载对应的about.hbs这个模版 我们还可以给模版引擎中传一些动态参数，这样就会渲染出来不同的内容，将about.hbs改成如下内容： 1234&lt;h1&gt;黑马前端&lt;/h1&gt;&lt;p&gt;学前端，来黑马&lt;/p&gt;&lt;p&gt;讲师：&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/p&gt; 然后在渲染该模版时加上第二个参数: 1234app.get(&#x27;/about&#x27;, (req, res) =&gt; &#123; // 渲染about.hbs模版 res.render(&#x27;about&#x27;, &#123; name: &#x27;jackie&#x27;, age: 18 &#125;);&#125;) 这样当渲染出来的时候就会根据我们传进去的参数动态渲染前端页面了 静态文件服务客户端一般需要访问一些图片视频等静态资源文件，那么这些文件如何发送给客户端呢，就需要用到静态文件服务了，而 Express 已经自带了静态文件服务中间件 express.static，使用起来非常方便。 假设我们的静态资源在public下面： 12345public├── css│ └── style.css└── img └── logo.png 然后我们只需要在server.js中添加一行代码： 1app.use(express.static(&#x27;public&#x27;)); 然后我们就可以通过下面的路径访问到这些资源了： 12http://localhost:3000/css/style.csshttp://localhost:3000/img/logo.png 在模板引擎中放入这些资源的引入，我们就可以模板中使用了： 12345&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot; /&gt;&lt;h1&gt;express入门课程&lt;/h1&gt;&lt;p&gt;作为前端开发，Nodejs已经成了很多公司对我们这一岗位的硬性要求，而 Express 框架则是其中知名度最高、也是最受欢迎的Nodejs开发框架。。。&lt;/p&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt; 再次运行服务器，并访问我们的网站时，就发现样式加到了我们的前端页面上了。 处理404和服务器错误我们在访问一些路由时有可能这个路由没有定义，这个时候就会返回404的状态码，或者有时候服务器内部代码出错了，就会返回500的错误码，这些情况是在开发中经常碰到的，那么服务端应该如何处理这些异常的情况呢？ 对于 404，只需在所有路由之后再加一个中间件，用来接收所有路由均匹配失败的请求 对于错误处理，前面所有中间件抛出异常时都会进入错误处理函数，可以使用 Express 自带的，也可以自定义。 处理404只需在server.js中添加如下代码： 123app.use(&#x27;*&#x27;, (req, res) =&gt; &#123; res.status(404).render(&#x27;404&#x27;, &#123; url: req.originalUrl &#125;);&#125;); 然后在views下面新建一个404.hbs的模版文件： 12&lt;h1&gt;找不到你要的页面了！&lt;/h1&gt;&lt;p&gt;你所访问的路径 &#123;&#123; url &#125;&#125; 不存在&lt;/p&gt; * 表示匹配任何路径。将此中间件放在所有路由后面，即可捕获所有访问路径均匹配失败的请求，然后渲染404的那个模版引擎就可以了。 注意：一定是放在所有路由的后面，只有前面的路由都匹配不上才会匹配到*的这个路由 处理内部错误在server.js中添加如下代码： 123app.use((err, req, res, next) =&gt; &#123; res.status(500).render(&#x27;500&#x27;);&#125;); 然后在views下面新建一个500.hbs的模版文件： 12&lt;h1&gt;服务器好像开小差了&lt;/h1&gt;&lt;p&gt;过一会儿再试试看吧！See your later~&lt;/p&gt; 注意：在server.js中添加的代码也必须要添加到所有路由的后面，不然不能处理全部的错误 我们在某个路由中手动抛出一个错误后，客户端就会渲染500.hbs这个模版文件。 总结至此express基础内容就讲解完了，这些都是express的核心知识点，后续还会有express的进阶课程，到时候会涉及到用express操作数据库和实战的内容，感兴趣的话可以关注我们的b站动态，及时跟进课程。","categories":[],"tags":[]},{"title":"","slug":"寒假学习","date":"2024-01-12T07:32:34.988Z","updated":"2024-09-29T13:23:38.955Z","comments":true,"path":"2024/01/12/寒假学习/","permalink":"http://eastyn7.github.io/2024/01/12/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"title：寒假学习第一周Vue2传参 查询参数传参（更适合多个参数）：?参数&#x3D;参数值 &#x3D;&gt; this.$route.query.参数名 动态路由传参（更适合单个参数）：&#x2F;路径&#x2F;参数 &#x3D;&gt; this.$route.params.参数名 组件缓存keep-alive将缓存所有切换的组件 三个属性：include——组件名数组，只有匹配的组件会被缓存 ​ exclude——组件名数组，任何匹配的组件都不会被缓存 ​ max——最多可以缓存多少组件实例 1234567&lt;template&gt; &lt;div&gt; &lt;keep-alive :include=&quot;[&#x27;LayoutPage&#x27;]&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 组件缓存了之后就不会再执行created、mounted、destroyed等钩子 提供了两个声明周期函数：activated(){} deactivated(){} 利用VueX创建仓库 利用mutations修改数据，this.$store.comit(‘方法名’) mapState映射到计算属性 mapMutations映射到方法 mapActons映射到方法 mapGetters映射到计算属性 actions处理异步，setTimeout模拟发请求 123456789actions:&#123; setAsynCount(context,num)&#123; setTimeout(()=&gt;&#123; context.comit(&#x27;changeCount&#x27;,num) &#125;,1000) &#125;&#125;this.$store.dispatch(&#x27;setAsyncCount&#x27;,200) modules模块拆分子仓，便于维护 在子模块中写namespaced: true可以直接利用mapState映射其中的内容 $store.getters[‘模块名&#x2F;xxx’] 请求拦截器12345678910111213141516171819202122232425262728293031323334353637/* 封装axios用于发送请求 */import axios from &#x27;axios&#x27;import &#123; Toast &#125; from &#x27;vant&#x27;// 创建一个新的axios实例const request = axios.create(&#123; baseURL: &#x27;http://cba.itlike.com/public/index.php?s=/api/&#x27;, timeout: 5000&#125;)// 添加请求拦截器request.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error)&#125;)// 添加响应拦截器request.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 const res = response.data console.log(res) if (res.status !== 200) &#123; // 给提示 Toast(res.message) // 抛错误promise return Promise.reject(res.message) &#125; return res&#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error)&#125;)export default request storage存储模块防止vuex刷新丢失，同时避免每次存取操作太长太麻烦的问题 12345678910111213141516171819// 约定一个通用的键名const INFO_KEY = &#x27;hm_shopping_info&#x27;// 获取个人信息export const getInfo = () =&gt; &#123; const defaultObj = &#123; token: &#x27;&#x27;, userId: &#x27;&#x27; &#125; const result = localStorage.getItem(INFO_KEY) return result ? JSON.parse(result) : defaultObj&#125;// 设置个人信息export const setInfo = (obj) =&gt; &#123; localStorage.setItem(INFO_KEY, JSON.stringify(obj))&#125;// 移除个人信息export const removeInfo = () =&gt; &#123; localStorage.removeItem(INFO_KEY)&#125; 登录节流操作1234567// 开启loading，禁止背景点击（节流处理，防止多次无效触发）Toast.loading(&#123; message: &#x27;加载中...&#x27;, forbidClick: true, // 禁止背景点击 loadingType: &#x27;spinner&#x27;, // 配置图标 duration: 0 // 不会自动消失，响应拦截器回来之后关闭&#125;) 123456789if (res.status !== 200) &#123; // 给提示 Toast(res.message) // 抛错误promise return Promise.reject(res.message)&#125; else &#123; // 正确清除loading效果 Toast.clear()&#125; 页面访问拦截设置全局前置路由 123router.beforeEach(to,from,next)=&gt;&#123; // to 往哪里去;from 从哪里来;next()是否放行,如果next()调用则放行,next(路径)拦截到某个路径页面&#125; 本周总结一直在跟着用vue2实现完整的商城项目，另外空余时间逐步在过渡vue3的基础知识，最近几天在搞三创赛需要用到的网页设计 第二周Vue31创建：npm init vue@latest setup允许在script中直接编写组合是API，setup()钩子执行时期早于beforeCreate()钩子，并且不再能使用this，数据和函数需要再setup最后return，语法糖写法省略了return template不再要求唯一根元素 reactive()和ref()reactive()作用：接受对象类型数据的参数传入并返回一个响应式的对象 12345678910111213141516&lt;script setup&gt;import &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123; count:100&#125;)const setCount = () =&gt; &#123; state.count++&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; state.count &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;setCount&quot;&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; ref()作用：接收简单类型或对象类型的数据传入并返回一个响应式的对象 ​ 本质：是在原有传入数据的基础上，外层包了一层对象 ​ 在脚本中访问数据需要通过.value，在template中不需要加.value 1234567891011121314&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)const setCount = () =&gt; &#123; count.value++&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; state.count &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;setCount&quot;&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 组合式API-computed123456789101112131415&lt;script setup&gt;import &#123; ref,computed &#125; from &#x27;vue&#x27;const list = ref([1,2,3,4,5,6,7,8])const computedList = computed(()=&#123; return list.value.filter(item =&gt; item &gt; 2)&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;原始数据：&#123;&#123; list &#125;&#125;&lt;/div&gt; &lt;div&gt;计算后数据:&#123;&#123; computedList &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 组合式API-watch作用：侦听一个或多个数据的变化，数据变化时执行回调函数 两个额外参数：immediate（立即执行）；deep（深度监听） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;script setup&gt;import &#123; ref,watch &#125; from &#x27;vue&#x27;const count = ref(0)const nickname = ref(&#x27;张三&#x27;)const changeCount = ()=&gt;&#123; count.value++&#125;const cangeNickname = ()=&gt;&#123; nickname.value = &#x27;李四&#x27;&#125;// 监视单个watch(count,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue)&#125;) // 监视多个watch([count,nickname],(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue)&#125;) // 立即执行watch(count,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue)&#125;,&#123; immediate:true&#125;) // 深度监视[ref(简单类型)可以监听,ref(复杂类型)必须深度监听]const userInfo = ref(&#123; name:&#x27;zs&#x27;, age:18&#125;)const setUserInfo = ()=&gt;&#123; userInfo.value.age++&#125;watch(userInfo,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue)&#125;,&#123; deep:true&#125;) // 对于对象中的属性进行监视const userInfo = ref(&#123; name:&#x27;zs&#x27;, age:18&#125;)const setUserInfo = ()=&gt;&#123; userInfo.value.age++&#125;watch(() =&gt; userInfo.value.age,(newValue,oldValue) =&gt; &#123; console.log(newValue,oldValue)&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;changeCount&quot;&gt; 改数字 &lt;/button&gt; &lt;div&gt; &#123;&#123; nickname &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;changeNickname&quot;&gt; 改昵称 &lt;/button&gt;&lt;/template&gt; 组合式API-生命周期函数 选项式API 组合式API beforeCreate&#x2F;created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBreforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted 组合式API-父子通信父传子：父组件给子组件绑定属性，子组件内部通过props选项接收，通过defineProps“编译器宏”接收子组件传递的数据 子传父：父组件中组件标签通过@绑定事件，子组件内部通过emit方法触发事件，通过defineEmits编译器宏生成emit方法 组合式API-模板引用调用ref函数生成一个ref对象，通过ref标识绑定ref对象到标签 1234567891011121314151617181920212223242526&lt;scipt setup&gt; import TestCom from &quot;@/components/........&quot; import &#123; ref, onMounted &#125; from &#x27;vue&#x27; const inp = ref(null) // 生命钩子onMounted等dom渲染完 onMounted(()=&gt;&#123; // console.log(inp.value) // inp.value.focus() &#125;) const clickFn = ()=&gt;&#123; inp.value.focus() &#125;&lt;/scipt&gt;&lt;template&gt; &lt;div&gt; &lt;input ref=&quot;inp&quot; type=&quot;text&quot;&gt; &lt;button @click=&quot;clickFn&quot;&gt; 点击让输入框聚焦 &lt;/button&gt; &lt;/div&gt; &lt;TestCom/&gt;&lt;/template&gt; 默认情况下在语法糖下组件内部的属性和方法是不开放给父组件访问的,可以通过defineExpose编译宏指定哪些属性和方法允许访问 1234567&lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const testMessage = ref(&#x27;this is test message&#x27;) defineExpose(&#123; testMessage &#125;)&lt;/script&gt; 组合式API-provide和inject顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信 普通数据 12// 顶层组件provide(&#x27;key&#x27;,顶层组件中的数据) 12// 底层组件const message = inject(&#x27;key&#x27;) 响应式数据 12// 顶层组件provide(&#x27;app-key&#x27;,ref对象) 12// 底层组件const message = inject(&#x27;app-key&#x27;) 方法 12345// 顶层组件const setCount = () =&gt; &#123; count,value++&#125;provide(&#x27;setCount-key&#x27;,setCount) 12// 底层组件const setCount = inject(&#x27;setCount-key&#x27;) defineOptions用defineOptions定义任意的选项，props、emits、expose、slots除外 1234567&lt;script setup&gt; defineOptions(&#123; name:&#x27;&#x27;, inheritAttrs:false, ......... &#125;)&lt;/script&gt; PiniaVuex的替代品 手动添加pinia 123456789import &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import App from &#x27;./App.vue&#x27;const pinia = createPinia()const app = createApp(App)app.use(pinia)app.use(&#x27;#app&#x27;) 基础使用：定义store，组件使用store 12345678910111213141516171819202122import &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; ref,computed &#125; from &#x27;vue&#x27;// 定义store// defineStore(仓库的唯一标识),() =&gt; &#123;....&#125;)export const useCOunterStore = defineStore(&#x27;counter&#x27;,() =&gt; &#123; // 声明数据 state const count = ref(0) // 声明操作数据的方法 actions （普通函数） const addCount = () =&gt; count.value++ // 声明基于数据派生的计算属性 getters （computed） const double = computed(() =&gt; count.value * 2) return &#123; count, double, addCount &#125;&#125;) 1234567891011&lt;script setup&gt; import &#123; useCounterStore &#125; from &#x27;@/store/....&#x27; const counterStore = useCounterStore()&lt;/script&gt;&lt;template&gt; &lt;div&gt; 我是Son1.vue - &#123;&#123; counterStore.count &#125;&#125; - &#123;&#123; counterStore.double &#125;&#125; &lt;button @click=&quot;counterStore.addCount&quot;&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; stpreTpRefs - 可以使pinia产生的store解构赋值数据保持响应式 Pinia持久化——白雪localStorage 下载依赖，导入，使用 import persist from &#39;pinia-plugun-persistedstate&#39; - 导入持久化插件 app.use(pinia.use(persist)) - piania插件的安装配置 persist:true - 在组合式的第三个参数中添加开启当前模块的持久化（默认是整个state被持久化到localStorage） pnpm 第三周el-row/el-col/el-formel-row 一行分为24份 el-col :span=&quot;12&quot; 该列占12份 el-col :offset:&quot;3&quot; 左外边距3份 el-form 表单 el-form-item 表单中的每一个元素 表单校验规则 非空校验——required:true message消息提示 trigger触发校验的时机 blur(失焦时)\\change(改变时) 长度校验——min:xx max:xx 正则校验——pattern:正则规则(例如: \\^\\S{6,15}$\\ 表示6-25位的非空字符) 自定义校验——validator:(rule,value,callback) rule 当前校验规则相关的信息 value 所校验的表单元素目前的表单值 callback 无论成功还是失败都需要callback callback() 校验成功 callback(new Errir(错误信息)) 校验失败 第四周node的http模块搭建的后端服务1234567891011const http = require(&#x27;http&#x27;)const server = http.createServer(function(req,res)&#123; res.statusCode = 200 res.setHeader(&#x27;Content-Type&#x27;,&#x27;Content-Type&#x27;,&#x27;text/html&#x27;) res.send(&#x27;...&#x27;)&#125;)server.listen(3000,functon()&#123; console.log(&#x27;服务已启动&#x27;) &#125;) 运行：node server.js express搭建后端服务安装：npm install express 123456789101112const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;,function(req,res)&#123; // 相应内容 res.send(&#x27;...&#x27;)&#125;)app.listen(3000,functon()&#123; console.log(&#x27;服务已启动&#x27;) &#125;) 在 Express 中，中间件就是一个函数：1234function someMiddleware(req, res, next) &#123; // 自定义逻辑 next();&#125; 三个参数中，req 和 res 就是前面提到的 Request 请求对象和 Response 响应对象；而 next 函数则用来触发下一个中间件的执行。 全局中间件通过 app.use 函数就可以注册中间件，并且此中间件会在用户发起任何请求都可能会执行，例如： 1app.use(someMiddleware) 路由中间件通过在路由定义时注册中间件，此中间件只会在用户访问该路由时执行，例如： 123app.get(&#x27;/middleware&#x27;, someMiddleware, (req, res) =&gt; &#123; res.send(&#x27;Hello World&#x27;);&#125;); 编写一个日志中间件 新建一个logger.js，并写入以下函数 1234567function logger(req, res, next) &#123; const time = new Date(); console.log(`[$&#123;time.toLocaleString()&#125;] $&#123;req.method&#125; $&#123;req.url&#125;`); next();&#125;module.exports = logger; 在server.js引入logger函数并且全局注册 123456const logger = require(&#x27;./logger&#x27;)......app.use(logger)...... 这样我们在访问路由后，每次都会在控制台打印一行日志，如下： 12[2023/2/27 15:54:29] GET /[2023/2/27 15:54:47] POST /about 注意：如果忘记在中间件中调用 next 函数，并且又不直接返回响应时，服务器会直接卡在这个中间件不会继续执行下去哦！","categories":[],"tags":[]}],"categories":[],"tags":[]}