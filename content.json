{"meta":{"title":"Eastyn的博客","subtitle":"","description":"","author":"Eastyn","url":"http://eastyn7.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-09-28T17:32:05.000Z","updated":"2024-09-28T17:34:04.765Z","comments":false,"path":"about/index.html","permalink":"http://eastyn7.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"黑马大事件后端","slug":"ev_api_server","date":"2024-10-08T15:39:53.500Z","updated":"2024-10-14T10:40:01.848Z","comments":true,"path":"2024/10/08/ev_api_server/","permalink":"http://eastyn7.github.io/2024/10/08/ev_api_server/","excerpt":"","text":"Headline 大事件后台 API 项目，API 接口文档请参考 https://www.showdoc.cc/escook?page_id&#x3D;3707158761215217 1. 初始化1.1 创建项目 新建 api_server 文件夹作为项目根目录，并在项目根目录中运行如下的命令，初始化包管理配置文件： 1npm init -y 运行如下的命令，安装特定版本的 express： 1npm i express@4.17.1 在项目根目录中新建 app.js 作为整个项目的入口文件，并初始化如下的代码： 1234567891011// 导入 express 模块const express = require(&#x27;express&#x27;)// 创建 express 的服务器实例const app = express()// write your code here...// 调用 app.listen 方法，指定端口号并启动web服务器app.listen(3007, function () &#123; console.log(&#x27;api server running at http://127.0.0.1:3007&#x27;)&#125;) 1.2 配置 cors 跨域 运行如下的命令，安装 cors 中间件： 1npm i cors@2.8.5 在 app.js 中导入并配置 cors 中间件： 1234// 导入 cors 中间件const cors = require(&#x27;cors&#x27;)// 将 cors 注册为全局中间件app.use(cors()) 1.3 配置解析表单数据的中间件 通过如下的代码，配置解析 application/x-www-form-urlencoded 格式的表单数据的中间件： 1app.use(express.urlencoded(&#123; extended: false &#125;)) 1.4 初始化路由相关的文件夹 在项目根目录中，新建 router 文件夹，用来存放所有的路由模块 路由模块中，只存放客户端的请求与处理函数之间的映射关系 在项目根目录中，新建 router_handler 文件夹，用来存放所有的 路由处理函数模块 路由处理函数模块中，专门负责存放每个路由对应的处理函数 1.5 初始化用户路由模块 在 router 文件夹中，新建 user.js 文件，作为用户的路由模块，并初始化代码如下： 12345678910111213141516const express = require(&#x27;express&#x27;)// 创建路由对象const router = express.Router()// 注册新用户router.post(&#x27;/reguser&#x27;, (req, res) =&gt; &#123; res.send(&#x27;reguser OK&#x27;)&#125;)// 登录router.post(&#x27;/login&#x27;, (req, res) =&gt; &#123; res.send(&#x27;login OK&#x27;)&#125;)// 将路由对象共享出去module.exports = router 在 app.js 中，导入并使用 用户路由模块 ： 123// 导入并注册用户路由模块const userRouter = require(&#x27;./router/user&#x27;)app.use(&#x27;/api&#x27;, userRouter) 1.6 抽离用户路由模块中的处理函数 目的：为了保证 路由模块 的纯粹性，所有的 路由处理函数，必须抽离到对应的 路由处理函数模块 中 在 /router_handler/user.js 中，使用 exports 对象，分别向外共享如下两个 路由处理函数 ： 12345678910111213/** * 在这里定义和用户相关的路由处理函数，供 /router/user.js 模块进行调用 */// 注册用户的处理函数exports.regUser = (req, res) =&gt; &#123; res.send(&#x27;reguser OK&#x27;)&#125;// 登录的处理函数exports.login = (req, res) =&gt; &#123; res.send(&#x27;login OK&#x27;)&#125; 将 /router/user.js 中的代码修改为如下结构： 123456789101112const express = require(&#x27;express&#x27;)const router = express.Router()// 导入用户路由处理函数模块const userHandler = require(&#x27;../router_handler/user&#x27;)// 注册新用户router.post(&#x27;/reguser&#x27;, userHandler.regUser)// 登录router.post(&#x27;/login&#x27;, userHandler.login)module.exports = router 2. 登录注册2.1 新建 ev_users 表 在 my_db_01 数据库中，新建 ev_users 表如下： 2.2 安装并配置 mysql 模块 在 API 接口项目中，需要安装并配置 mysql 这个第三方模块，来连接和操作 MySQL 数据库 运行如下命令，安装 mysql 模块： 1npm i mysql@2.18.1 在项目根目录中新建 /db/index.js 文件，在此自定义模块中创建数据库的连接对象： 12345678910111213// 导入 mysql 模块const mysql = require(&#x27;mysql&#x27;)// 创建数据库连接对象const db = mysql.createPool(&#123; host: &#x27;127.0.0.1&#x27;, user: &#x27;root&#x27;, password: &#x27;admin123&#x27;, database: &#x27;my_db_01&#x27;,&#125;)// 向外共享 db 数据库连接对象module.exports = db 2.3 注册2.3.0 实现步骤 检测表单数据是否合法 检测用户名是否被占用 对密码进行加密处理 插入新用户 2.3.1 检测表单数据是否合法 判断用户名和密码是否为空 123456// 接收表单数据const userinfo = req.body// 判断数据是否合法if (!userinfo.username || !userinfo.password) &#123; return res.send(&#123; status: 1, message: &#x27;用户名或密码不能为空！&#x27; &#125;)&#125; 2.3.2 检测用户名是否被占用 导入数据库操作模块： 1const db = require(&#x27;../db/index&#x27;) 定义 SQL 语句： 1const sql = `select * from ev_users where username=?` 执行 SQL 语句并根据结果判断用户名是否被占用： 1234567891011db.query(sql, [userinfo.username], function (err, results) &#123; // 执行 SQL 语句失败 if (err) &#123; return res.send(&#123; status: 1, message: err.message &#125;) &#125; // 用户名被占用 if (results.length &gt; 0) &#123; return res.send(&#123; status: 1, message: &#x27;用户名被占用，请更换其他用户名！&#x27; &#125;) &#125; // TODO: 用户名可用，继续后续流程...&#125;) 2.3.3 对密码进行加密处理 为了保证密码的安全性，不建议在数据库以 明文 的形式保存用户密码，推荐对密码进行 加密存储 在当前项目中，使用 bcryptjs 对用户密码进行加密，优点： 加密之后的密码，无法被逆向破解 同一明文密码多次加密，得到的加密结果各不相同，保证了安全性 运行如下命令，安装指定版本的 bcryptjs ： 1npm i bcryptjs@2.4.3 在 /router_handler/user.js 中，导入 bcryptjs ： 1const bcrypt = require(&#x27;bcryptjs&#x27;) 在注册用户的处理函数中，确认用户名可用之后，调用 bcrypt.hashSync(明文密码, 随机盐的长度) 方法，对用户的密码进行加密处理： 12// 对用户的密码,进行 bcrype 加密，返回值是加密之后的密码字符串userinfo.password = bcrypt.hashSync(userinfo.password, 10) 2.3.4 插入新用户 定义插入用户的 SQL 语句： 1const sql = &#x27;insert into ev_users set ?&#x27; 调用 db.query() 执行 SQL 语句，插入新用户： 12345678910db.query(sql, &#123; username: userinfo.username, password: userinfo.password &#125;, function (err, results) &#123; // 执行 SQL 语句失败 if (err) return res.send(&#123; status: 1, message: err.message &#125;) // SQL 语句执行成功，但影响行数不为 1 if (results.affectedRows !== 1) &#123; return res.send(&#123; status: 1, message: &#x27;注册用户失败，请稍后再试！&#x27; &#125;) &#125; // 注册成功 res.send(&#123; status: 0, message: &#x27;注册成功！&#x27; &#125;)&#125;) 2.4 优化 res.send() 代码 在处理函数中，需要多次调用 res.send() 向客户端响应 处理失败 的结果，为了简化代码，可以手动封装一个 res.cc() 函数 在 app.js 中，所有路由之前，声明一个全局中间件，为 res 对象挂载一个 res.cc() 函数 ： 12345678910111213// 响应数据的中间件app.use(function (req, res, next) &#123; // status = 0 为成功； status = 1 为失败； 默认将 status 的值设置为 1，方便处理失败的情况 res.cc = function (err, status = 1) &#123; res.send(&#123; // 状态 status, // 状态描述，判断 err 是 错误对象 还是 字符串 message: err instanceof Error ? err.message : err, &#125;) &#125; next()&#125;) 2.5 优化表单数据验证 表单验证的原则：前端验证为辅，后端验证为主，后端永远不要相信前端提交过来的任何内容 在实际开发中，前后端都需要对表单的数据进行合法性的验证，而且，后端做为数据合法性验证的最后一个关口，在拦截非法数据方面，起到了至关重要的作用。 单纯的使用 if...else... 的形式对数据合法性进行验证，效率低下、出错率高、维护性差。因此，推荐使用第三方数据验证模块，来降低出错率、提高验证的效率与可维护性，让后端程序员把更多的精力放在核心业务逻辑的处理上。 安装 @hapi/joi 包，为表单中携带的每个数据项，定义验证规则： 1npm install @hapi/joi@17.1.0 安装 @escook/express-joi 中间件，来实现自动对表单数据进行验证的功能： 1npm i @escook/express-joi 新建 /schema/user.js 用户信息验证规则模块，并初始化代码如下： 123456789101112131415161718192021222324252627const joi = require(&#x27;@hapi/joi&#x27;)/** * string() 值必须是字符串 * alphanum() 值只能是包含 a-zA-Z0-9 的字符串 * min(length) 最小长度 * max(length) 最大长度 * required() 值是必填项，不能为 undefined * pattern(正则表达式) 值必须符合正则表达式的规则 */// 用户名的验证规则const username = joi.string().alphanum().min(1).max(10).required()// 密码的验证规则const password = joi .string() .pattern(/^[\\S]&#123;6,12&#125;$/) .required()// 注册和登录表单的验证规则对象exports.reg_login_schema = &#123; // 表示需要对 req.body 中的数据进行验证 body: &#123; username, password, &#125;,&#125; 修改 /router/user.js 中的代码如下： 1234567891011121314151617181920const express = require(&#x27;express&#x27;)const router = express.Router()// 导入用户路由处理函数模块const userHandler = require(&#x27;../router_handler/user&#x27;)// 1. 导入验证表单数据的中间件const expressJoi = require(&#x27;@escook/express-joi&#x27;)// 2. 导入需要的验证规则对象const &#123; reg_login_schema &#125; = require(&#x27;../schema/user&#x27;)// 注册新用户// 3. 在注册新用户的路由中，声明局部中间件，对当前请求中携带的数据进行验证// 3.1 数据验证通过后，会把这次请求流转给后面的路由处理函数// 3.2 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理router.post(&#x27;/reguser&#x27;, expressJoi(reg_login_schema), userHandler.regUser)// 登录router.post(&#x27;/login&#x27;, userHandler.login)module.exports = router 在 app.js 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端： 123456789const joi = require(&#x27;@hapi/joi&#x27;)// 错误中间件app.use(function (err, req, res, next) &#123; // 数据验证失败 if (err instanceof joi.ValidationError) return res.cc(err) // 未知错误 res.cc(err)&#125;) 2.6 登录2.6.0 实现步骤 检测表单数据是否合法 根据用户名查询用户的数据 判断用户输入的密码是否正确 生成 JWT 的 Token 字符串 2.6.1 检测登录表单的数据是否合法 将 /router/user.js 中 登录 的路由代码修改如下： 12// 登录的路由router.post(&#x27;/login&#x27;, expressJoi(reg_login_schema), userHandler.login) 2.6.2 根据用户名查询用户的数据 接收表单数据： 1const userinfo = req.body 定义 SQL 语句： 1const sql = `select * from ev_users where username=?` 执行 SQL 语句，查询用户的数据： 1234567db.query(sql, userinfo.username, function (err, results) &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // 执行 SQL 语句成功，但是查询到数据条数不等于 1 if (results.length !== 1) return res.cc(&#x27;登录失败！&#x27;) // TODO：判断用户输入的登录密码是否和数据库中的密码一致&#125;) 2.6.3 判断用户输入的密码是否正确 核心实现思路：调用 bcrypt.compareSync(用户提交的密码, 数据库中的密码) 方法比较密码是否一致 返回值是布尔值（true 一致、false 不一致） 具体的实现代码如下： 123456789// 拿着用户输入的密码,和数据库中存储的密码进行对比const compareResult = bcrypt.compareSync(userinfo.password, results[0].password)// 如果对比的结果等于 false, 则证明用户输入的密码错误if (!compareResult) &#123; return res.cc(&#x27;登录失败！&#x27;)&#125;// TODO：登录成功，生成 Token 字符串 2.6.4 生成 JWT 的 Token 字符串 核心注意点：在生成 Token 字符串的时候，一定要剔除 密码 和 头像 的值 通过 ES6 的高级语法，快速剔除 密码 和 头像 的值： 12// 剔除完毕之后，user 中只保留了用户的 id, username, nickname, email 这四个属性的值const user = &#123; ...results[0], password: &#x27;&#x27;, user_pic: &#x27;&#x27; &#125; 运行如下的命令，安装生成 Token 字符串的包： 1npm i jsonwebtoken@8.5.1 在 /router_handler/user.js 模块的头部区域，导入 jsonwebtoken 包： 12// 用这个包来生成 Token 字符串const jwt = require(&#x27;jsonwebtoken&#x27;) 创建 config.js 文件，并向外共享 加密 和 还原 Token 的 jwtSecretKey 字符串： 123module.exports = &#123; jwtSecretKey: &#x27;itheima No1. ^_^&#x27;,&#125; 将用户信息对象加密成 Token 字符串： 1234567// 导入配置文件const config = require(&#x27;../config&#x27;)// 生成 Token 字符串const tokenStr = jwt.sign(user, config.jwtSecretKey, &#123; expiresIn: &#x27;10h&#x27;, // token 有效期为 10 个小时&#125;) 将生成的 Token 字符串响应给客户端： 123456res.send(&#123; status: 0, message: &#x27;登录成功！&#x27;, // 为了方便客户端使用 Token，在服务器端直接拼接上 Bearer 的前缀 token: &#x27;Bearer &#x27; + tokenStr,&#125;) 2.7 配置解析 Token 的中间件 运行如下的命令，安装解析 Token 的中间件： 1npm i express-jwt@5.3.3 在 app.js 中注册路由之前，配置解析 Token 的中间件： 12345678// 导入配置文件const config = require(&#x27;./config&#x27;)// 解析 token 的中间件const expressJWT = require(&#x27;express-jwt&#x27;)// 使用 .unless(&#123; path: [/^\\/api\\//] &#125;) 指定哪些接口不需要进行 Token 的身份认证app.use(expressJWT(&#123; secret: config.jwtSecretKey &#125;).unless(&#123; path: [/^\\/api\\//] &#125;)) 在 app.js 中的 错误级别中间件 里面，捕获并处理 Token 认证失败后的错误： 123456789// 错误中间件app.use(function (err, req, res, next) &#123; // 省略其它代码... // 捕获身份认证失败的错误 if (err.name === &#x27;UnauthorizedError&#x27;) return res.cc(&#x27;身份认证失败！&#x27;) // 未知错误...&#125;) 3. 个人中心3.1 获取用户的基本信息3.1.0 实现步骤 初始化 路由 模块 初始化 路由处理函数 模块 获取用户的基本信息 3.1.1 初始化路由模块 创建 /router/userinfo.js 路由模块，并初始化如下的代码结构： 123456789101112// 导入 expressconst express = require(&#x27;express&#x27;)// 创建路由对象const router = express.Router()// 获取用户的基本信息router.get(&#x27;/userinfo&#x27;, (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125;)// 向外共享路由对象module.exports = router 在 app.js 中导入并使用个人中心的路由模块： 1234// 导入并使用用户信息路由模块const userinfoRouter = require(&#x27;./router/userinfo&#x27;)// 注意：以 /my 开头的接口，都是有权限的接口，需要进行 Token 身份认证app.use(&#x27;/my&#x27;, userinfoRouter) 3.1.2 初始化路由处理函数模块 创建 /router_handler/userinfo.js 路由处理函数模块，并初始化如下的代码结构： 1234// 获取用户基本信息的处理函数exports.getUserInfo = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 修改 /router/userinfo.js 中的代码如下： 12345678910const express = require(&#x27;express&#x27;)const router = express.Router()// 导入用户信息的处理函数模块const userinfo_handler = require(&#x27;../router_handler/userinfo&#x27;)// 获取用户的基本信息router.get(&#x27;/userinfo&#x27;, userinfo_handler.getUserInfo)module.exports = router 3.1.3 获取用户的基本信息 在 /router_handler/userinfo.js 头部导入数据库操作模块： 12// 导入数据库操作模块const db = require(&#x27;../db/index&#x27;) 定义 SQL 语句： 123// 根据用户的 id，查询用户的基本信息// 注意：为了防止用户的密码泄露，需要排除 password 字段const sql = `select id, username, nickname, email, user_pic from ev_users where id=?` 调用 db.query() 执行 SQL 语句： 123456789101112131415// 注意：req 对象上的 user 属性，是 Token 解析成功，express-jwt 中间件帮我们挂载上去的db.query(sql, req.user.id, (err, results) =&gt; &#123; // 1. 执行 SQL 语句失败 if (err) return res.cc(err) // 2. 执行 SQL 语句成功，但是查询到的数据条数不等于 1 if (results.length !== 1) return res.cc(&#x27;获取用户信息失败！&#x27;) // 3. 将用户信息响应给客户端 res.send(&#123; status: 0, message: &#x27;获取用户基本信息成功！&#x27;, data: results[0], &#125;)&#125;) 3.2 更新用户的基本信息3.2.0 实现步骤 定义路由和处理函数 验证表单数据 实现更新用户基本信息的功能 3.2.1 定义路由和处理函数 在 /router/userinfo.js 模块中，新增 更新用户基本信息 的路由： 12// 更新用户的基本信息router.post(&#x27;/userinfo&#x27;, userinfo_handler.updateUserInfo) 在 /router_handler/userinfo.js 模块中，定义并向外共享 更新用户基本信息 的路由处理函数： 1234// 更新用户基本信息的处理函数exports.updateUserInfo = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 3.2.2 验证表单数据 在 /schema/user.js 验证规则模块中，定义 id，nickname，email 的验证规则如下： 1234// 定义 id, nickname, emial 的验证规则const id = joi.number().integer().min(1).required()const nickname = joi.string().required()const email = joi.string().email().required() 并使用 exports 向外共享如下的 验证规则对象： 12345678// 验证规则对象 - 更新用户基本信息exports.update_userinfo_schema = &#123; body: &#123; id, nickname, email, &#125;,&#125; 在 /router/userinfo.js 模块中，导入验证数据合法性的中间件： 12// 导入验证数据合法性的中间件const expressJoi = require(&#x27;@escook/express-joi&#x27;) 在 /router/userinfo.js 模块中，导入需要的验证规则对象： 12// 导入需要的验证规则对象const &#123; update_userinfo_schema &#125; = require(&#x27;../schema/user&#x27;) 在 /router/userinfo.js 模块中，修改 更新用户的基本信息 的路由如下： 12// 更新用户的基本信息router.post(&#x27;/userinfo&#x27;, expressJoi(update_userinfo_schema), userinfo_handler.updateUserInfo) 3.2.3 实现更新用户基本信息的功能 定义待执行的 SQL 语句： 1const sql = `update ev_users set ? where id=?` 调用 db.query() 执行 SQL 语句并传参： 12345678910db.query(sql, [req.body, req.body.id], (err, results) =&gt; &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // 执行 SQL 语句成功，但影响行数不为 1 if (results.affectedRows !== 1) return res.cc(&#x27;修改用户基本信息失败！&#x27;) // 修改用户信息成功 return res.cc(&#x27;修改用户基本信息成功！&#x27;, 0)&#125;) 3.3 重置密码3.3.0 实现步骤 定义路由和处理函数 验证表单数据 实现重置密码的功能 3.3.1 定义路由和处理函数 在 /router/userinfo.js 模块中，新增 重置密码 的路由： 12// 重置密码的路由router.post(&#x27;/updatepwd&#x27;, userinfo_handler.updatePassword) 在 /router_handler/userinfo.js 模块中，定义并向外共享 重置密码 的路由处理函数： 1234// 重置密码的处理函数exports.updatePassword = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 3.3.2 验证表单数据 核心验证思路：旧密码与新密码，必须符合密码的验证规则，并且新密码不能与旧密码一致！ 在 /schema/user.js 模块中，使用 exports 向外共享如下的 验证规则对象： 12345678910111213// 验证规则对象 - 重置密码exports.update_password_schema = &#123; body: &#123; // 使用 password 这个规则，验证 req.body.oldPwd 的值 oldPwd: password, // 使用 joi.not(joi.ref(&#x27;oldPwd&#x27;)).concat(password) 规则，验证 req.body.newPwd 的值 // 解读： // 1. joi.ref(&#x27;oldPwd&#x27;) 表示 newPwd 的值必须和 oldPwd 的值保持一致 // 2. joi.not(joi.ref(&#x27;oldPwd&#x27;)) 表示 newPwd 的值不能等于 oldPwd 的值 // 3. .concat() 用于合并 joi.not(joi.ref(&#x27;oldPwd&#x27;)) 和 password 这两条验证规则 newPwd: joi.not(joi.ref(&#x27;oldPwd&#x27;)).concat(password), &#125;,&#125; 在 /router/userinfo.js 模块中，导入需要的验证规则对象： 12// 导入需要的验证规则对象const &#123; update_userinfo_schema, update_password_schema &#125; = require(&#x27;../schema/user&#x27;) 并在 重置密码的路由 中，使用 update_password_schema 规则验证表单的数据，示例代码如下： 1router.post(&#x27;/updatepwd&#x27;, expressJoi(update_password_schema), userinfo_handler.updatePassword) 3.3.3 实现重置密码的功能 根据 id 查询用户是否存在： 12345678910111213// 定义根据 id 查询用户数据的 SQL 语句const sql = `select * from ev_users where id=?`// 执行 SQL 语句查询用户是否存在db.query(sql, req.user.id, (err, results) =&gt; &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // 检查指定 id 的用户是否存在 if (results.length !== 1) return res.cc(&#x27;用户不存在！&#x27;) // TODO：判断提交的旧密码是否正确&#125;) 判断提交的 旧密码 是否正确： 12345678// 在头部区域导入 bcryptjs 后，// 即可使用 bcrypt.compareSync(提交的密码，数据库中的密码) 方法验证密码是否正确// compareSync() 函数的返回值为布尔值，true 表示密码正确，false 表示密码错误const bcrypt = require(&#x27;bcryptjs&#x27;)// 判断提交的旧密码是否正确const compareResult = bcrypt.compareSync(req.body.oldPwd, results[0].password)if (!compareResult) return res.cc(&#x27;原密码错误！&#x27;) 对新密码进行 bcrypt 加密之后，更新到数据库中： 1234567891011121314151617// 定义更新用户密码的 SQL 语句const sql = `update ev_users set password=? where id=?`// 对新密码进行 bcrypt 加密处理const newPwd = bcrypt.hashSync(req.body.newPwd, 10)// 执行 SQL 语句，根据 id 更新用户的密码db.query(sql, [newPwd, req.user.id], (err, results) =&gt; &#123; // SQL 语句执行失败 if (err) return res.cc(err) // SQL 语句执行成功，但是影响行数不等于 1 if (results.affectedRows !== 1) return res.cc(&#x27;更新密码失败！&#x27;) // 更新密码成功 res.cc(&#x27;更新密码成功！&#x27;, 0)&#125;) 3.4 更新用户头像3.4.0 实现步骤 定义路由和处理函数 验证表单数据 实现更新用户头像的功能 3.4.1 定义路由和处理函数 在 /router/userinfo.js 模块中，新增 更新用户头像 的路由： 12// 更新用户头像的路由router.post(&#x27;/update/avatar&#x27;, userinfo_handler.updateAvatar) 在 /router_handler/userinfo.js 模块中，定义并向外共享 更新用户头像 的路由处理函数： 1234// 更新用户头像的处理函数exports.updateAvatar = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 3.4.2 验证表单数据 在 /schema/user.js 验证规则模块中，定义 avatar 的验证规则如下： 123// dataUri() 指的是如下格式的字符串数据：// data:image/png;base64,VE9PTUFOWVNFQ1JFVFM=const avatar = joi.string().dataUri().required() 并使用 exports 向外共享如下的 验证规则对象： 123456// 验证规则对象 - 更新头像exports.update_avatar_schema = &#123; body: &#123; avatar, &#125;,&#125; 在 /router/userinfo.js 模块中，导入需要的验证规则对象： 1const &#123; update_avatar_schema &#125; = require(&#x27;../schema/user&#x27;) 在 /router/userinfo.js 模块中，修改 更新用户头像 的路由如下： 1router.post(&#x27;/update/avatar&#x27;, expressJoi(update_avatar_schema), userinfo_handler.updateAvatar) 3.4.3 实现更新用户头像的功能 定义更新用户头像的 SQL 语句： 1const sql = &#x27;update ev_users set user_pic=? where id=?&#x27; 调用 db.query() 执行 SQL 语句，更新对应用户的头像： 12345678910db.query(sql, [req.body.avatar, req.user.id], (err, results) =&gt; &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // 执行 SQL 语句成功，但是影响行数不等于 1 if (results.affectedRows !== 1) return res.cc(&#x27;更新头像失败！&#x27;) // 更新用户头像成功 return res.cc(&#x27;更新头像成功！&#x27;, 0)&#125;) 4. 文章分类管理4.1 新建 ev_article_cate 表4.1.1 创建表结构 4.1.2 新增两条初始数据 4.2 获取文章分类列表4.2.0 实现步骤 初始化路由模块 初始化路由处理函数模块 获取文章分类列表数据 4.2.1 初始化路由模块 创建 /router/artcate.js 路由模块，并初始化如下的代码结构： 123456789101112// 导入 expressconst express = require(&#x27;express&#x27;)// 创建路由对象const router = express.Router()// 获取文章分类的列表数据router.get(&#x27;/cates&#x27;, (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125;)// 向外共享路由对象module.exports = router 在 app.js 中导入并使用文章分类的路由模块： 1234// 导入并使用文章分类路由模块const artCateRouter = require(&#x27;./router/artcate&#x27;)// 为文章分类的路由挂载统一的访问前缀 /my/articleapp.use(&#x27;/my/article&#x27;, artCateRouter) 4.2.2 初始化路由处理函数模块 创建 /router_handler/artcate.js 路由处理函数模块，并初始化如下的代码结构： 1234// 获取文章分类列表数据的处理函数exports.getArticleCates = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 修改 /router/artcate.js 中的代码如下： 12345678910const express = require(&#x27;express&#x27;)const router = express.Router()// 导入文章分类的路由处理函数模块const artcate_handler = require(&#x27;../router_handler/artcate&#x27;)// 获取文章分类的列表数据router.get(&#x27;/cates&#x27;, artcate_handler.getArticleCates)module.exports = router 4.2.3 获取文章分类列表数据 在 /router_handler/artcate.js 头部导入数据库操作模块： 12// 导入数据库操作模块const db = require(&#x27;../db/index&#x27;) 定义 SQL 语句： 123// 根据分类的状态，获取所有未被删除的分类列表数据// is_delete 为 0 表示没有被 标记为删除 的数据const sql = &#x27;select * from ev_article_cate where is_delete=0 order by id asc&#x27; 调用 db.query() 执行 SQL 语句： 1234567891011db.query(sql, (err, results) =&gt; &#123; // 1. 执行 SQL 语句失败 if (err) return res.cc(err) // 2. 执行 SQL 语句成功 res.send(&#123; status: 0, message: &#x27;获取文章分类列表成功！&#x27;, data: results, &#125;)&#125;) 4.3 新增文章分类4.3.0 实现步骤 定义路由和处理函数 验证表单数据 查询 分类名称 与 分类别名 是否被占用 实现新增文章分类的功能 4.3.1 定义路由和处理函数 在 /router/artcate.js 模块中，添加 新增文章分类 的路由： 12// 新增文章分类的路由router.post(&#x27;/addcates&#x27;, artcate_handler.addArticleCates) 在 /router_handler/artcate.js 模块中，定义并向外共享 新增文章分类 的路由处理函数： 1234// 新增文章分类的处理函数exports.addArticleCates = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 4.3.2 验证表单数据 创建 /schema/artcate.js 文章分类数据验证模块，并定义如下的验证规则： 1234567891011121314// 导入定义验证规则的模块const joi = require(&#x27;@hapi/joi&#x27;)// 定义 分类名称 和 分类别名 的校验规则const name = joi.string().required()const alias = joi.string().alphanum().required()// 校验规则对象 - 添加分类exports.add_cate_schema = &#123; body: &#123; name, alias, &#125;,&#125; 在 /router/artcate.js 模块中，使用 add_cate_schema 对数据进行验证： 1234567// 导入验证数据的中间件const expressJoi = require(&#x27;@escook/express-joi&#x27;)// 导入文章分类的验证模块const &#123; add_cate_schema &#125; = require(&#x27;../schema/artcate&#x27;)// 新增文章分类的路由router.post(&#x27;/addcates&#x27;, expressJoi(add_cate_schema), artcate_handler.addArticleCates) 4.3.3 查询分类名称与别名是否被占用 定义查重的 SQL 语句： 12// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句const sql = `select * from ev_article_cate where name=? or alias=?` 调用 db.query() 执行查重的操作： 12345678910111213// 执行查重操作db.query(sql, [req.body.name, req.body.alias], (err, results) =&gt; &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // 判断 分类名称 和 分类别名 是否被占用 if (results.length === 2) return res.cc(&#x27;分类名称与别名被占用，请更换后重试！&#x27;) // 分别判断 分类名称 和 分类别名 是否被占用 if (results.length === 1 &amp;&amp; results[0].name === req.body.name) return res.cc(&#x27;分类名称被占用，请更换后重试！&#x27;) if (results.length === 1 &amp;&amp; results[0].alias === req.body.alias) return res.cc(&#x27;分类别名被占用，请更换后重试！&#x27;) // TODO：新增文章分类&#125;) 4.3.4 实现新增文章分类的功能 定义新增文章分类的 SQL 语句： 1const sql = `insert into ev_article_cate set ?` 调用 db.query() 执行新增文章分类的 SQL 语句： 12345678910db.query(sql, req.body, (err, results) =&gt; &#123; // SQL 语句执行失败 if (err) return res.cc(err) // SQL 语句执行成功，但是影响行数不等于 1 if (results.affectedRows !== 1) return res.cc(&#x27;新增文章分类失败！&#x27;) // 新增文章分类成功 res.cc(&#x27;新增文章分类成功！&#x27;, 0)&#125;) 4.4 根据 Id 删除文章分类4.4.0 实现步骤 定义路由和处理函数 验证表单数据 实现删除文章分类的功能 4.4.1 定义路由和处理函数 在 /router/artcate.js 模块中，添加 删除文章分类 的路由： 12// 删除文章分类的路由router.get(&#x27;/deletecate/:id&#x27;, artcate_handler.deleteCateById) 在 /router_handler/artcate.js 模块中，定义并向外共享 删除文章分类 的路由处理函数： 1234// 删除文章分类的处理函数exports.deleteCateById = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 4.4.2 验证表单数据 在 /schema/artcate.js 验证规则模块中，定义 id 的验证规则如下： 12// 定义 分类Id 的校验规则const id = joi.number().integer().min(1).required() 并使用 exports 向外共享如下的 验证规则对象： 123456// 校验规则对象 - 删除分类exports.delete_cate_schema = &#123; params: &#123; id, &#125;,&#125; 在 /router/artcate.js 模块中，导入需要的验证规则对象，并在路由中使用： 12345// 导入删除分类的验证规则对象const &#123; delete_cate_schema &#125; = require(&#x27;../schema/artcate&#x27;)// 删除文章分类的路由router.get(&#x27;/deletecate/:id&#x27;, expressJoi(delete_cate_schema), artcate_handler.deleteCateById) 4.4.3 实现删除文章分类的功能 定义删除文章分类的 SQL 语句： 1const sql = `update ev_article_cate set is_delete=1 where id=?` 调用 db.query() 执行删除文章分类的 SQL 语句： 12345678910db.query(sql, req.params.id, (err, results) =&gt; &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // SQL 语句执行成功，但是影响行数不等于 1 if (results.affectedRows !== 1) return res.cc(&#x27;删除文章分类失败！&#x27;) // 删除文章分类成功 res.cc(&#x27;删除文章分类成功！&#x27;, 0)&#125;) 4.5 根据 Id 获取文章分类数据4.5.0 实现步骤 定义路由和处理函数 验证表单数据 实现获取文章分类的功能 4.5.1 定义路由和处理函数 在 /router/artcate.js 模块中，添加 根据 Id 获取文章分类 的路由： 1router.get(&#x27;/cates/:id&#x27;, artcate_handler.getArticleById) 在 /router_handler/artcate.js 模块中，定义并向外共享 根据 Id 获取文章分类 的路由处理函数： 1234// 根据 Id 获取文章分类的处理函数exports.getArticleById = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 4.5.2 验证表单数据 在 /schema/artcate.js 验证规则模块中，使用 exports 向外共享如下的 验证规则对象： 123456// 校验规则对象 - 根据 Id 获取分类exports.get_cate_schema = &#123; params: &#123; id, &#125;,&#125; 在 /router/artcate.js 模块中，导入需要的验证规则对象，并在路由中使用： 12345// 导入根据 Id 获取分类的验证规则对象const &#123; get_cate_schema &#125; = require(&#x27;../schema/artcate&#x27;)// 根据 Id 获取文章分类的路由router.get(&#x27;/cates/:id&#x27;, expressJoi(get_cate_schema), artcate_handler.getArticleById) 4.5.3 实现获取文章分类的功能 定义根据 Id 获取文章分类的 SQL 语句： 1const sql = `select * from ev_article_cate where id=?` 调用 db.query() 执行 SQL 语句： 1234567891011121314db.query(sql, req.params.id, (err, results) =&gt; &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // SQL 语句执行成功，但是没有查询到任何数据 if (results.length !== 1) return res.cc(&#x27;获取文章分类数据失败！&#x27;) // 把数据响应给客户端 res.send(&#123; status: 0, message: &#x27;获取文章分类数据成功！&#x27;, data: results[0], &#125;)&#125;) 4.6 根据 Id 更新文章分类数据4.6.0 实现步骤 定义路由和处理函数 验证表单数据 查询 分类名称 与 分类别名 是否被占用 实现更新文章分类的功能 4.6.1 定义路由和处理函数 在 /router/artcate.js 模块中，添加 更新文章分类 的路由： 12// 更新文章分类的路由router.post(&#x27;/updatecate&#x27;, artcate_handler.updateCateById) 在 /router_handler/artcate.js 模块中，定义并向外共享 更新文章分类 的路由处理函数： 1234// 更新文章分类的处理函数exports.updateCateById = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 4.6.2 验证表单数据 在 /schema/artcate.js 验证规则模块中，使用 exports 向外共享如下的 验证规则对象： 12345678// 校验规则对象 - 更新分类exports.update_cate_schema = &#123; body: &#123; Id: id, name, alias, &#125;,&#125; 在 /router/artcate.js 模块中，导入需要的验证规则对象，并在路由中使用： 12345// 导入更新文章分类的验证规则对象const &#123; update_cate_schema &#125; = require(&#x27;../schema/artcate&#x27;)// 更新文章分类的路由router.post(&#x27;/updatecate&#x27;, expressJoi(update_cate_schema), artcate_handler.updateCateById) 4.5.4 查询分类名称与别名是否被占用 定义查重的 SQL 语句： 12// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句const sql = `select * from ev_article_cate where Id&lt;&gt;? and (name=? or alias=?)` 调用 db.query() 执行查重的操作： 123456789101112// 执行查重操作db.query(sql, [req.body.Id, req.body.name, req.body.alias], (err, results) =&gt; &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // 判断 分类名称 和 分类别名 是否被占用 if (results.length === 2) return res.cc(&#x27;分类名称与别名被占用，请更换后重试！&#x27;) if (results.length === 1 &amp;&amp; results[0].name === req.body.name) return res.cc(&#x27;分类名称被占用，请更换后重试！&#x27;) if (results.length === 1 &amp;&amp; results[0].alias === req.body.alias) return res.cc(&#x27;分类别名被占用，请更换后重试！&#x27;) // TODO：更新文章分类&#125;) 4.5.5 实现更新文章分类的功能 定义更新文章分类的 SQL 语句： 1const sql = `update ev_article_cate set ? where Id=?` 调用 db.query() 执行 SQL 语句： 12345678910db.query(sql, [req.body, req.body.Id], (err, results) =&gt; &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // SQL 语句执行成功，但是影响行数不等于 1 if (results.affectedRows !== 1) return res.cc(&#x27;更新文章分类失败！&#x27;) // 更新文章分类成功 res.cc(&#x27;更新文章分类成功！&#x27;, 0)&#125;) 5. 文章管理5.1 新建 ev_articles 表 5.2 发布新文章5.2.0 实现步骤 初始化路由模块 初始化路由处理函数模块 使用 multer 解析表单数据 验证表单数据 实现发布文章的功能 5.2.1 初始化路由模块 创建 /router/article.js 路由模块，并初始化如下的代码结构： 123456789101112// 导入 expressconst express = require(&#x27;express&#x27;)// 创建路由对象const router = express.Router()// 发布新文章router.post(&#x27;/add&#x27;, (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125;)// 向外共享路由对象module.exports = router 在 app.js 中导入并使用文章的路由模块： 1234// 导入并使用文章路由模块const articleRouter = require(&#x27;./router/article&#x27;)// 为文章的路由挂载统一的访问前缀 /my/articleapp.use(&#x27;/my/article&#x27;, articleRouter) 5.2.2 初始化路由处理函数模块 创建 /router_handler/article.js 路由处理函数模块，并初始化如下的代码结构： 1234// 发布新文章的处理函数exports.addArticle = (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125; 修改 /router/article.js 中的代码如下： 12345678910const express = require(&#x27;express&#x27;)const router = express.Router()// 导入文章的路由处理函数模块const article_handler = require(&#x27;../router_handler/article&#x27;)// 发布新文章router.post(&#x27;/add&#x27;, article_handler.addArticle)module.exports = router 5.2.3 使用 multer 解析表单数据 注意：使用 express.urlencoded() 中间件无法解析 multipart/form-data 格式的请求体数据。 当前项目，推荐使用 multer 来解析 multipart/form-data 格式的表单数据。https://www.npmjs.com/package/multer 运行如下的终端命令，在项目中安装 multer： 1npm i multer@1.4.2 在 /router_handler/article.js 模块中导入并配置 multer： 1234567// 导入解析 formdata 格式表单数据的包const multer = require(&#x27;multer&#x27;)// 导入处理路径的核心模块const path = require(&#x27;path&#x27;)// 创建 multer 的实例对象，通过 dest 属性指定文件的存放路径const upload = multer(&#123; dest: path.join(__dirname, &#x27;../uploads&#x27;) &#125;) 修改 发布新文章 的路由如下： 12345// 发布新文章的路由// upload.single() 是一个局部生效的中间件，用来解析 FormData 格式的表单数据// 将文件类型的数据，解析并挂载到 req.file 属性中// 将文本类型的数据，解析并挂载到 req.body 属性中router.post(&#x27;/add&#x27;, upload.single(&#x27;cover_img&#x27;), article_handler.addArticle) 在 /router_handler/article.js 模块中的 addArticle 处理函数中，将 multer 解析出来的数据进行打印： 12345678// 发布新文章的处理函数exports.addArticle = (req, res) =&gt; &#123; console.log(req.body) // 文本类型的数据 console.log(&#x27;--------分割线----------&#x27;) console.log(req.file) // 文件类型的数据 res.send(&#x27;ok&#x27;)&#125;) 5.2.4 验证表单数据 实现思路：通过 express-joi 自动验证 req.body 中的文本数据；通过 if 判断手动验证 req.file 中的文件数据； 创建 /schema/article.js 验证规则模块，并初始化如下的代码结构： 123456789101112131415161718// 导入定义验证规则的模块const joi = require(&#x27;@hapi/joi&#x27;)// 定义 标题、分类Id、内容、发布状态 的验证规则const title = joi.string().required()const cate_id = joi.number().integer().min(1).required()const content = joi.string().required().allow(&#x27;&#x27;)const state = joi.string().valid(&#x27;已发布&#x27;, &#x27;草稿&#x27;).required()// 验证规则对象 - 发布文章exports.add_article_schema = &#123; body: &#123; title, cate_id, content, state, &#125;,&#125; 在 /router/article.js 模块中，导入需要的验证规则对象，并在路由中使用： 12345678910// 导入验证数据的中间件const expressJoi = require(&#x27;@escook/express-joi&#x27;)// 导入文章的验证模块const &#123; add_article_schema &#125; = require(&#x27;../schema/article&#x27;)// 发布新文章的路由// 注意：在当前的路由中，先后使用了两个中间件：// 先使用 multer 解析表单数据// 再使用 expressJoi 对解析的表单数据进行验证router.post(&#x27;/add&#x27;, upload.single(&#x27;cover_img&#x27;), expressJoi(add_article_schema), article_handler.addArticle) 在 /router_handler/article.js 模块中的 addArticle 处理函数中，通过 if 判断客户端是否提交了 封面图片： 1234567// 发布新文章的处理函数exports.addArticle = (req, res) =&gt; &#123; // 手动判断是否上传了文章封面 if (!req.file || req.file.fieldname !== &#x27;cover_img&#x27;) return res.cc(&#x27;文章封面是必选参数！&#x27;) // TODO：表单数据合法，继续后面的处理流程...&#125;) 5.2.5 实现发布文章的功能 整理要插入数据库的文章信息对象： 12345678910111213// 导入处理路径的 path 核心模块const path = require(&#x27;path&#x27;)const articleInfo = &#123; // 标题、内容、状态、所属的分类Id ...req.body, // 文章封面在服务器端的存放路径 cover_img: path.join(&#x27;/uploads&#x27;, req.file.filename), // 文章发布时间 pub_date: new Date(), // 文章作者的Id author_id: req.user.id,&#125; 定义发布文章的 SQL 语句： 1const sql = `insert into ev_articles set ?` 调用 db.query() 执行发布文章的 SQL 语句： 1234567891011121314// 导入数据库操作模块const db = require(&#x27;../db/index&#x27;)// 执行 SQL 语句db.query(sql, articleInfo, (err, results) =&gt; &#123; // 执行 SQL 语句失败 if (err) return res.cc(err) // 执行 SQL 语句成功，但是影响行数不等于 1 if (results.affectedRows !== 1) return res.cc(&#x27;发布文章失败！&#x27;) // 发布文章成功 res.cc(&#x27;发布文章成功&#x27;, 0)&#125;) 在 app.js 中，使用 express.static() 中间件，将 uploads 目录中的图片托管为静态资源： 12// 托管静态资源文件app.use(&#x27;/uploads&#x27;, express.static(&#x27;./uploads&#x27;))","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-09-28T13:04:35.234Z","updated":"2024-09-28T13:04:35.234Z","comments":true,"path":"2024/09/28/hello-world/","permalink":"http://eastyn7.github.io/2024/09/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"HEXO搭建博客平台","slug":"利用HEXO搭搭建自己的博客","date":"2024-09-28T12:58:51.580Z","updated":"2024-09-29T13:11:17.384Z","comments":true,"path":"2024/09/28/利用HEXO搭搭建自己的博客/","permalink":"http://eastyn7.github.io/2024/09/28/%E5%88%A9%E7%94%A8HEXO%E6%90%AD%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"HEXO搭建博客平台本机环境 Win11 node.js：18.17.0 npm：10.8.2 安装下载hexo1npm install -g hexo-cli hexo -v 验证并查看版本 创建项目文件夹1hexo init myblog 安装12cd myblognpm install 启动服务12hexo ghexo server 在GitHub创建仓库安装hexo上传插件1npm install hexo-deployer-git --save 修改hexo配置文件指定仓库路径在文件夹中直接打开_config.yml文件修改 deploy: ​ type: git ​ repo : git地址 ​ branch: master 推送到GitHub1hexo d 跟新完 清理：hexo clean 构建：hexo g 上传：hexo d","categories":[],"tags":[]},{"title":"青队云平台开发","slug":"青队云平台开发文档","date":"2024-09-04T15:00:04.749Z","updated":"2024-10-15T15:41:44.517Z","comments":true,"path":"2024/09/04/青队云平台开发文档/","permalink":"http://eastyn7.github.io/2024/09/04/%E9%9D%92%E9%98%9F%E4%BA%91%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/","excerpt":"","text":"青队云平台开发文档💕启动时间：2024.09.04 项目概述背景随着志愿服务在高校中的蓬勃发展，“小红帽”常青藤青年志愿者服务队【以下简称青队】逐渐成为学院内外各类公益活动的重要组织者。作为一个由热心青年学生组成的志愿者队伍，我们的成员在多个领域积极参与，展现了良好的精神风貌和社会责任感。为了更好地提升服务队的内部管理和对外宣传，我们希望通过开发一个内部管理和展示平台，强化队伍凝聚力和成员归属感，同时向公众展示我们的成果和精神风貌。 当前问题和挑战1、队伍形象展示不足：服务队在学院和社会上的影响力有限，缺乏一个集中展示服务队历史、成就和活动的窗口，使外界难以充分了解我们的团队文化和核心价值观。 2、信息发布不及时：当前活动和内部信息的发布主要依赖于微信群、QQ群等非集中化渠道，容易导致信息遗漏或传播不及时，影响活动的参与率和团队沟通效率。 3、志愿精神传递不足：在提升成员志愿服务精神、技能培训和经验分享方面缺少有效的工具和手段，难以为新成员提供系统性的成长路径和支持。 项目目标本项目旨在为青队开发一个专属的云平台，以解决以上问题，并实现以下目标： 1、展示队伍形象和成就：通过平台展示服务队的历史、团队文化、活动成果和优秀队员的风采，加强公众对服务队的认识和支持。 2、提升信息发布和沟通效率：通过平台发布公告、活动预告和内部信息，确保成员能够及时获取最新信息，提升队内沟通效率。 3、促进志愿精神传播与成长：提供志愿者学习资源、经验分享和培训支持，帮助成员成长，并有效传播志愿服务精神。 数据库设计用户登录信息表（user_auth)1234567891011CREATE TABLE `user_login` ( `auth_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;认证ID&#x27;, `student_id` varchar(10) NOT NULL COMMENT &#x27;学号&#x27;, `email` varchar(50) NOT NULL COMMENT &#x27;邮箱，要求@ctbu.edu.cn结尾&#x27;, `password_hash` varchar(255) NOT NULL COMMENT &#x27;密码哈希值&#x27;, `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;账号创建时间&#x27;, `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;最后更新时间&#x27;, PRIMARY KEY (`auth_id`), UNIQUE KEY `unique_email` (`email`), UNIQUE KEY `unique_student_id` (`student_id`)); 触发器 注册时同步创建一个新的用户信息 12345BEGIN -- 插入到 user_info 中，并将 username 设置为 student_id INSERT INTO `user_info` (auth_id, username) VALUES (NEW.auth_id, NEW.student_id);END 用户详细信息表(user_info)12345678910111213CREATE TABLE `user_info` ( `auth_id` int NOT NULL COMMENT &#x27;关联认证表的外键&#x27;, `role` tinyint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;用户角色（0=普通用户, 1=超级管理员, 2=普通管理员）&#x27;, `nickname` varchar(64) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `username` varchar(18) DEFAULT NULL COMMENT &#x27;真实姓名&#x27;, `gender` tinyint NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;性别（0=未指定, 1=男, 2=女）&#x27;, `avatar` varchar(255) DEFAULT NULL COMMENT &#x27;头像URL&#x27;, `phone` varchar(11) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`auth_id`), CONSTRAINT `user_info_ibfk_1` FOREIGN KEY (`auth_id`) REFERENCES `user_login` (`auth_id`) ON DELETE CASCADE); 功能设计首页（&#x2F;home） 轮播图 小公告 队徽队名 功能宫格【校园服务通、爱心雨伞、服务队活动风采、志愿活动报名、关于青队、用户意见反馈】 个人中心（&#x2F;user） 未登录情况 默认登录栏（默认头像、点击登录） 选择列表（个人资料、权限申请、使用指南、设置）【需要登录之后才能点击使用】 已登录情况 已登录状态栏（登录头像、名称） 选择列表（个人资料、权限申请（审核）、?后台管理、使用指南、设置） 关于青队（About Us）前端开发创建前端项目1pnpm create vue 配置Vant添加vant 1pnpm add vant 安装自动导入插件 1pnpm add @vant/auto-import-resolver unplugin-vue-components unplugin-auto-import -D 配置自动导入 1234567891011121314151617181920212223242526import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;;import Components from &#x27;unplugin-vue-components/vite&#x27;;import &#123; VantResolver &#125; from &#x27;@vant/auto-import-resolver&#x27;;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; // vant按需导入 resolvers: [VantResolver()], &#125;), Components(&#123; resolvers: [VantResolver()], &#125;) ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;&#125;) 配置自动导入和组件1234567891011121314151617181920212223242526272829AutoImport(&#123; include: [ /\\.[tj]sx?$/, // .ts, .tsx, .js, .jsx /\\.vue$/, /\\.vue\\?vue/, // .vue /\\.md$/ // .md ], imports: [&#x27;vue&#x27;, &#x27;vue-router&#x27;, &#x27;pinia&#x27;], // 配置导出的文件 dts: &#x27;src/auto-import.d.ts&#x27;, // vue、vue-router ts类型导出位置 // vant按需导入 resolvers: [VantResolver()], // eslint 配置 eslintrc: &#123; enabled: true, // 当配置 enabled: true 时，会根据 filepath 配置的路径生成一个 .eslintrc-auto-import.json 文件 filepath: &#x27;src/.eslintrc-auto-import.json&#x27;, globalsPropValue: true &#125; &#125;), Components(&#123; // 搜索子目录 deep: true, // 组件有效的扩展名 extensions: [&#x27;vue&#x27;, &#x27;js&#x27;, &#x27;jsx&#x27;, &#x27;ts&#x27;, &#x27;tsx&#x27;, &#x27;.mjs&#x27;], include: [/\\.vue$/, /\\.vue\\?vue/, /\\.js$/, /\\.jsx$/, /\\.ts$/, /\\.tsx$/], resolvers: [VantResolver()], dirs: [&#x27;src/components&#x27;], dts: &#x27;src/components.d.ts&#x27;, directives: true &#125;) 配置Eslint和Prettier123456789101112131415161718192021rules: &#123; &#x27;prettier/prettier&#x27;: [ &#x27;warn&#x27;, &#123; singleQuote: true, semi: false, printWidth: 100, trailingComma: &#x27;none&#x27;, endOfLine: &#x27;auto&#x27; &#125; ], &#x27;vue/multi-word-component-names&#x27;: [ &#x27;warn&#x27;, &#123; ignores: [&#x27;index&#x27;] &#125; ], &#x27;vue/no-setup-props-destructure&#x27;: [&#x27;off&#x27;] // &#x27;no-undef&#x27;: &#x27;error&#x27;&#125; 配置Viewport安装插件 1pnpm install postcss-px-to-viewport -D 配置 12345678910111213141516171819/* eslint-env node */// postcss.config.cjsmodule.exports = &#123; plugins: &#123; &#x27;postcss-px-to-viewport&#x27;: &#123; uniToConvert: &#x27;px&#x27;, // 需要转换的单位 &#x27;默认px&#x27; viewportWidth: 375, // 设计稿的视口宽度 unitPrecision: 5, // 单位转换后保留的小数位数 proList: [&#x27;*&#x27;], // 要进行转换的属性列表 ,*表示匹配所有 viewportUnit: &#x27;vw&#x27;, // 转换后的视口单位 selectorBlackList: [&#x27;.ignore&#x27;, &#x27;.hairlines&#x27;], // 不转换的选择器列表 fontViewportUnit: &#x27;vw&#x27;, // 转换后字体使用的视口单位 minPixelValue: 1, // 设置最小的转换数值 replace: true, // 是否直接转化而不添加备用属性 mediaQuery: true, // 是否允许在媒体查询中转换 exclude: [/node_modules/] // 忽略某些文件夹下的文件 &#125;, &#125;,&#125;; 配置Axios安装Axios 1pnpm add axios 配置Request文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import axios from &#x27;axios&#x27;import type &#123; InternalAxiosRequestConfig &#125; from &#x27;axios&#x27;import &#123; getLocalData, removeLocalData, isLogin &#125; from &#x27;@/utils/util&#x27;// 自定义请求配置接口，扩展了 Axios 的配置选项，增加了 needToken 属性interface CustomRequestConfig extends InternalAxiosRequestConfig &#123; needToken?: boolean // 标识请求是否需要携带Token&#125;// 创建axios实例，并设置基础配置const http = axios.create(&#123; baseURL: import.meta.env.VITE_BASE_URL, // API的基础URL，使用Vite的环境变量来设置 timeout: 10000 // 请求超时时间为10秒&#125;)// 请求拦截器：在请求发送之前做一些处理http.interceptors.request.use( (config: CustomRequestConfig) =&gt; &#123; // 判断当前请求是否需要Token if (config.needToken) &#123; // 检查是否已登录 if (isLogin()) &#123; // 从本地存储中获取用户信息 const userinfo = getLocalData(&#x27;userinfo&#x27;) if (userinfo) &#123; // 如果用户信息存在，将Token添加到请求头中 config.headers[&#x27;Authorization&#x27;] = `Bearer $&#123;userinfo.sk&#125;` // sk 为用户密钥字段 &#125; &#125; // 如果用户未登录，但本地有Token过期时间 else if (getLocalData(&#x27;token_expires_at&#x27;)) &#123; // 移除过期的用户信息和Token removeLocalData(&#x27;userinfo&#x27;) removeLocalData(&#x27;token_expires_at&#x27;) // 提示用户登录已过期 showFailToast(&#x27;登录已过期，请重新登录&#x27;) &#125; // 用户未登录且没有过期的Token else &#123; // 提示用户先登录 showFailToast(&#x27;请先登录&#x27;) &#125; &#125; // 为所有请求设置请求头，指定请求内容类型为x-www-form-urlencoded config.headers[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27; // 返回处理后的请求配置 return config &#125;, (error) =&gt; &#123; // 如果请求发生错误，直接返回错误 return Promise.reject(error) &#125;)// 响应拦截器：在响应返回之后做一些处理http.interceptors.response.use( (response) =&gt; &#123; // 只返回响应的data部分，简化后续调用的数据处理 return response.data &#125;, (error) =&gt; &#123; // 如果响应发生错误，返回错误 return Promise.reject(error) &#125;)// 导出处理好的 http 实例export default http 配置Pinia安装插件 1pnpm add pinia-plugin-persistedstate -D 在仓库中导入 123456789101112131415import &#123; createPinia &#125; from &#x27;pinia&#x27;import persist from &#x27;pinia-plugin-persistedstate&#x27;const pinia = createPinia()pinia.use(persist)import &#123; useCounterStore &#125; from &#x27;./counter&#x27; // 举例导入export default piniaexport const useStore = () =&gt; &#123; return &#123; counter: useCounterStore() &#125;&#125; 配置Vant底部安全区适配123/* index.html */&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover&quot;/&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/viewportFit.css&quot;&gt; 12345678/* viewportFit.css *//* 适配 iphone 底部安全区（指示条，配合index.html &lt;meta name=&quot;viewport&quot; ... /&gt;使用 */@supports (bottom: env(safe-area-inset-bottom))&#123; #app &#123; padding-bottom: constant(safe-area-inset-bottom);/* 兼容ios&lt;11.2 */ padding-bottom: env(safe-area-inset-bottom);/* 兼容ios&gt;=11.2 */ &#125;&#125; 配置全局样式1234567891011121314151617181920212223242526/* src/styles/index.css */#app &#123; max-width: 1280px; margin: 0 auto; padding: 0.5rem; font-weight: normal;&#125;html &#123; line-height: 1.2;&#125;body &#123; background-color: rgba(194, 194, 194, 0.131); font-family: &#x27;KaiTi&#x27;, &#x27;楷体&#x27;, &#x27;STKaiti&#x27;, &#x27;SimSun&#x27;, &#x27;黑体&#x27;, &#x27;Heiti SC&#x27;, &#x27;Arial&#x27;, sans-serif; color: #3e3e3e; margin: 0; padding: 0; box-sizing: border-box;&#125;h1, h2, h3, h4, h5, h6 &#123; color: #222; font-family: &#x27;KaiTi&#x27;, &#x27;楷体&#x27;;&#125; 配置路由1234567891011121314151617181920212223242526272829303132import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import indexRoutes from &#x27;./routes&#x27;const router = createRouter(&#123; history: createWebHashHistory(), routes: [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/home&#x27;, children: [ &#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: () =&gt; import(&#x27;@/views/Home/HomeView.vue&#x27;) &#125;, &#123; path: &#x27;/user&#x27;, name: &#x27;User&#x27;, component: () =&gt; import(&#x27;@/views/User/UserView.vue&#x27;) &#125;, &#123; path: &#x27;/notice&#x27;, name: &#x27;Notice&#x27;, component: () =&gt; import(&#x27;@/views/Notice/NoticeView.vue&#x27;) &#125; ] &#125;, ...indexRoutes //基础功能页面 ]&#125;)export default router 其他路由 1234567891011121314151617181920212223242526272829303132333435/* indexRoutes.ts */const routes = [ &#123; path: &#x27;/campusservice&#x27;, name: &#x27;CampusService&#x27;, component: () =&gt; import(&#x27;@/views/CampusService/CampusService.vue&#x27;) &#125;, &#123; path: &#x27;/loveumbrella&#x27;, name: &#x27;LoveUmbrella&#x27;, component: () =&gt; import(&#x27;@/views/LoveUmbrella/LoveUmbrella.vue&#x27;) &#125;, &#123; path: &#x27;/activities&#x27;, name: &#x27;Activities&#x27;, component: () =&gt; import(&#x27;@/views/Activities/Activities.vue&#x27;) &#125;, &#123; path: &#x27;/signup&#x27;, name: &#x27;SignUp&#x27;, component: () =&gt; import(&#x27;@/views/SignUp/SignUp.vue&#x27;) &#125;, &#123; path: &#x27;/aboutus&#x27;, name: &#x27;AboutUs&#x27;, component: () =&gt; import(&#x27;@/views/AboutUs/AboutUs.vue&#x27;) &#125;, &#123; path: &#x27;/feedback&#x27;, name: &#x27;Feedback&#x27;, component: () =&gt; import(&#x27;@/views/Feedback/Feedback.vue&#x27;) &#125;]export default routes 配置阿里图标 在阿里图标官网创建项目，并将选好的图标保存到项目中，再将项目下载下来 把下载的项目中的文件（除了demo.css和demo_index.html文件）保存至该项目中 在main.ts中导入iconfont.css文件 在项目中使用icon=&quot; icon-great-activities&quot; icon-prefix=&quot;iconfont&quot;【需要注意的是图标类名前必须加一个空格】 App.vue12345678910111213141516171819202122232425262728293031323334&lt;script setup lang=&quot;ts&quot;&gt;const route = useRoute()&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;layout&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;van-tabbar route v-if=&quot;[&#x27;/&#x27;, &#x27;/home&#x27;, &#x27;/notice&#x27;, &#x27;/user&#x27;].includes(route.path)&quot; active-color=&quot;#1989fa&quot; inactive-color=&quot;#000&quot; placeholder &gt; &lt;van-tabbar-item replace to=&quot;/home&quot; icon=&quot;home-o&quot;&gt; 首页 &lt;/van-tabbar-item&gt; &lt;!-- 这里的`dot`红点通过判断是否有新更新的通知来控制 --&gt; &lt;van-tabbar-item replace to=&quot;/notice&quot; icon=&quot;chat-o&quot; :dot=&quot;false&quot;&gt; 通知 &lt;/van-tabbar-item&gt; &lt;van-tabbar-item replace to=&quot;/user&quot; icon=&quot;user-o&quot;&gt; 个人中心 &lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.van-tabbar-item &#123; background-color: rgb(255, 255, 255);&#125;&lt;/style&gt; 首页123456789101112131415161718192021&lt;script setup lang=&quot;ts&quot;&gt;// 定义一个响应式的文本变量，需要通过后端来控制文本内容，组件挂载（onMounted）时axios发请求const notification = ref&lt;string&gt;(&#x27;内容待管理员更新...&#x27;)&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;home-layout&quot;&gt; &lt;!-- 轮播图 --&gt; &lt;HomeSwipe /&gt; &lt;!-- 小公告 --&gt; &lt;HomeNoticeBar :notification=&quot;notification&quot; /&gt; &lt;!-- 队徽队名 --&gt; &lt;HomeTeamName /&gt; &lt;!-- 功能表 --&gt; &lt;HomeGrid /&gt; &lt;!-- 底线 --&gt; &lt;Divider dividerText=&quot;暂时没有更多功能&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 首页-轮播图 图片更新需要改成后端更新图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* components/HomeSwipe/index.vue */&lt;script setup lang=&quot;ts&quot;&gt;// 需要改成后端调用更新图片const SwipeImages = reactive([ &#123; imgUrl: &#x27;https://olrando.oss-cn-chengdu.aliyuncs.com/img/duiqi.jpg&#x27;, index: 0 &#125;, &#123; imgUrl: &#x27;https://olrando.oss-cn-chengdu.aliyuncs.com/img/1681282717068.jpeg&#x27;, index: 1 &#125;, &#123; imgUrl: &#x27;https://olrando.oss-cn-chengdu.aliyuncs.com/img/1681282717071.jpeg&#x27;, index: 2 &#125;, &#123; imgUrl: &#x27;https://olrando.oss-cn-chengdu.aliyuncs.com/img/1681282717075.jpeg&#x27;, index: 3 &#125;])&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;swipe-container&quot;&gt; &lt;!-- 轮播图上层部分 --&gt; &lt;div class=&quot;foreground&quot;&gt; &lt;van-swipe loop class=&quot;my-swipe-fore&quot; :autoplay=&quot;3000&quot; indicator-color=&quot;#1989fa&quot; :touchable=&quot;false&quot; &gt; &lt;van-swipe-item v-for=&quot;item in SwipeImages&quot; :key=&quot;item.index&quot;&gt; &lt;img :src=&quot;item.imgUrl&quot; /&gt; &lt;/van-swipe-item&gt; &lt;/van-swipe&gt; &lt;/div&gt; &lt;!-- 轮播图下层部分 --&gt; &lt;div class=&quot;background&quot;&gt; &lt;van-swipe loop class=&quot;my-swipe-back&quot; :autoplay=&quot;3000&quot; :touchable=&quot;false&quot;&gt; &lt;van-swipe-item v-for=&quot;item in SwipeImages&quot; :key=&quot;item.index&quot;&gt; &lt;img :src=&quot;item.imgUrl&quot; /&gt; &lt;/van-swipe-item&gt; &lt;/van-swipe&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.swipe-container &#123; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; border-radius: 20px 20px 20px 20px;&#125;.foreground &#123; z-index: 1;&#125;.my-swipe-fore &#123; border-radius: 20px 20px 20px 20px; height: 210px; width: 330px; margin: 20px 0px 20px 0px; box-shadow: 2px 2px 20px #3b2e32; border: transparent;&#125;.my-swipe-fore .van-swipe-item img &#123; width: 100%; height: 100%; border-radius: 20px 20px 20px 20px;&#125;.background &#123; z-index: 0; filter: blur(4px); opacity: 0.8; position: absolute;&#125;.my-swipe-back &#123; border-radius: 20px 20px 20px 20px; height: 240px; width: 365px;&#125;.my-swipe-back .van-swipe-item img &#123; width: 100%; height: 100%; border-radius: 20px 20px 20px 20px;&#125;&lt;/style&gt; 首页-小通知12345678910111213141516171819202122/* components/HomeNoticeBar/index.vue */&lt;script setup lang=&quot;ts&quot;&gt;// 使用类型声明来定义 Props 类型interface Props &#123; text?: string // 让 text 成为可选的&#125;// 使用 defineProps 来定义组件的 PropsdefineProps&lt;Props&gt;()&lt;/script&gt;&lt;template&gt; &lt;van-notice-bar scrollable left-icon=&quot;volume-o&quot; color=&quot;#1989fa&quot; background=&quot;#ecf9ff&quot; :text=&quot;text || &#x27;暂时没有公告哦~&#x27;&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 首页-队徽队名1234567891011121314151617181920212223/* components/HomeTeamName/index.vue */&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;TeamName&quot;&gt; &lt;img src=&quot;@/assets/images/透明队徽.png&quot; alt=&quot;&quot; /&gt; &lt;h3&gt;&quot;小红帽&quot;常青藤青年志愿者服务队&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.TeamName &#123; display: flex; align-items: center; justify-content: center; margin: 5px 0;&#125;.TeamName img &#123; width: 30px; height: 30px;&#125;&lt;/style&gt; 首页-宫格123456789101112131415161718192021222324252627282930313233343536373839404142434445/* components/HomeGrid/index.vue */&lt;template&gt; &lt;van-grid icon-size=&quot;30px&quot; :column-num=&quot;2&quot; clickable&gt; &lt;van-grid-item text=&quot;校园服务通&quot; icon=&quot; icon-campus-service&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/campusservice&quot; /&gt; &lt;van-grid-item text=&quot;爱心雨伞&quot; icon=&quot; icon-love-umbrella&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/loveumbrella&quot; /&gt; &lt;van-grid-item text=&quot;服务队活动风采&quot; icon=&quot; icon-great-activities&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/activities&quot; /&gt; &lt;van-grid-item text=&quot;志愿活动报名&quot; icon=&quot; icon-signup-activities&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/signup&quot; /&gt; &lt;van-grid-item text=&quot;关于青队&quot; icon=&quot; icon-about-us&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/aboutus&quot; /&gt; &lt;van-grid-item text=&quot;用户意见反馈&quot; icon=&quot; icon-feedback&quot; icon-prefix=&quot;iconfont&quot; to=&quot;/feedback&quot; /&gt; &lt;/van-grid&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 首页功能-用户问题反馈页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;script setup lang=&quot;ts&quot;&gt;// 通知消息const notification = ref&lt;string&gt;( &#x27;为了更好地提升我们的服务质量，我们诚挚邀请您提供宝贵的意见和建议&#x27;)// 表单数据const isAnonymous = ref&lt;boolean&gt;(false) // 控制是否匿名const username = ref&lt;string&gt;(&#x27;&#x27;)const phone = ref&lt;string&gt;(&#x27;&#x27;)const studentId = ref&lt;string&gt;(&#x27;&#x27;)const message = ref&lt;string&gt;(&#x27;&#x27;)// 验证规则const rules = &#123; username: [ &#123; required: !isAnonymous.value, message: &#x27;姓名不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125; ], phone: [ &#123; required: false &#125;, &#123; pattern: /^1[3-9]\\d&#123;9&#125;$/, message: &#x27;手机号格式错误&#x27;, trigger: &#x27;onBlur&#x27; &#125; ], studentId: [ &#123; required: !isAnonymous.value, message: &#x27;学号不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;, &#123; pattern: /^\\d&#123;8,12&#125;$/, message: &#x27;学号格式不正确&#x27;, trigger: &#x27;onBlur&#x27; &#125; // 学号假设为8到12位数字 ], message: [&#123; required: true, message: &#x27;反馈内容不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;]&#125;// 提交处理const onSubmit = () =&gt; &#123; // 提交表单逻辑 if (isAnonymous.value) &#123; console.log(&#x27;匿名提交反馈&#x27;) &#125; else &#123; console.log(&#x27;实名提交反馈&#x27;) &#125; showToast(&#x27;提交成功&#x27;)&#125;// 监听匿名开关状态变化，实时更新验证规则watch(isAnonymous, (newVal) =&gt; &#123; rules.username[0].required = !newVal rules.studentId[0].required = !newVal&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 小公告 --&gt; &lt;HomeNoticeBar :notification=&quot;notification&quot; /&gt; &lt;!-- 队徽队名 --&gt; &lt;HomeTeamName /&gt; &lt;van-form @submit=&quot;onSubmit&quot;&gt; &lt;van-cell-group inset&gt; &lt;!-- 姓名 --&gt; &lt;van-field v-model=&quot;username&quot; :rules=&quot;rules.username&quot; :required=&quot;rules.username[0].required&quot; label=&quot;姓名&quot; placeholder=&quot;请输入您的姓名&quot; v-if=&quot;!isAnonymous&quot; /&gt; &lt;!-- 学号 --&gt; &lt;van-field v-model=&quot;studentId&quot; :rules=&quot;rules.studentId&quot; :required=&quot;rules.studentId[0].required&quot; label=&quot;学号&quot; placeholder=&quot;请输入您的学号&quot; v-if=&quot;!isAnonymous&quot; /&gt; &lt;!-- 手机号 --&gt; &lt;van-field v-model=&quot;phone&quot; :rules=&quot;rules.phone&quot; :required=&quot;rules.phone[0].required&quot; label=&quot;手机号&quot; placeholder=&quot;请输入您的手机号&quot; v-if=&quot;!isAnonymous&quot; /&gt; &lt;!-- 反馈内容 --&gt; &lt;van-field v-model=&quot;message&quot; :rules=&quot;rules.message&quot; :required=&quot;rules.message[0].required&quot; rows=&quot;2&quot; autosize label=&quot;反馈内容&quot; type=&quot;textarea&quot; maxlength=&quot;1000&quot; placeholder=&quot;请输入反馈内容&quot; show-word-limit /&gt; &lt;van-field name=&quot;switch&quot; label=&quot;匿名提交&quot;&gt; &lt;template #input&gt; &lt;van-switch v-model=&quot;isAnonymous&quot; /&gt; &lt;/template&gt; &lt;/van-field&gt; &lt;/van-cell-group&gt; &lt;div style=&quot;margin: 16px&quot;&gt; &lt;van-button round block type=&quot;primary&quot; native-type=&quot;submit&quot;&gt; 提交 &lt;/van-button&gt; &lt;/div&gt; &lt;/van-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 个人中心12345678910111213141516171819202122232425&lt;script setup&gt;import UserIsLoginView from &#x27;@/views/User/UserIsLogin/UserIsLoginView.vue&#x27;import UserUnLoginView from &#x27;@/views/User/UserUnLogin/UserUnLoginView.vue&#x27;// import&#123;isLogin&#125; from &#x27;@/utils/util&#x27;let show = ref(false)// onMounted(() =&gt; &#123;// if (isLogin()) &#123;// show.value = true// &#125; else &#123;// show.value = false// &#125;// &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;UserUnLoginView v-if=&quot;show&quot; /&gt; &lt;UserIsLoginView v-else /&gt; &lt;Divider dividerText=&quot;人工智能学院 “小红帽”常青藤青年志愿者服务队&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; 个人中心-未登录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;script setup lang=&quot;ts&quot;&gt;const menuItems = [ &#123; icon: &#x27; icon-personal-data&#x27;, classPrefix: &#x27;iconfont&#x27;, text: &#x27;个人资料&#x27;, routerLink: &#x27;&#x27; &#125;, &#123; icon: &#x27; icon-permission-application&#x27;, classPrefix: &#x27;iconfont&#x27;, text: &#x27;权限申请&#x27;, routerLink: &#x27;&#x27; &#125;, &#123; icon: &#x27; icon-operating-guide&#x27;, classPrefix: &#x27;iconfont&#x27;, text: &#x27;使用指南&#x27;, routerLink: &#x27;/operatingguide&#x27; &#125;, &#123; icon: &#x27; icon-setting&#x27;, classPrefix: &#x27;iconfont&#x27;, text: &#x27;设置&#x27;, routerLink: &#x27;&#x27; &#125;]const login = () =&gt; &#123; showToast(&#123; message: &#x27;正在开发中...&#x27;, position: &#x27;top&#x27; &#125;)&#125;const toastFn = () =&gt; &#123; showToast(&#123; message: &#x27;请登录之后再使用&#x27;, position: &#x27;top&#x27; &#125;)&#125;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;defaultProfile&quot; @click=&quot;login&quot;&gt; &lt;div class=&quot;defaultAvatar&quot;&gt; &lt;van-icon name=&quot; icon-default-avatar&quot; class-prefix=&quot;iconfont&quot; size=&quot;80&quot; /&gt; &lt;div class=&quot;defaultText&quot;&gt;点击登录&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;defaultSection&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in menuItems&quot; :key=&quot;item.text&quot; @click=&quot;toastFn()&quot;&gt; &lt;router-link :to=&quot;item.routerLink&quot; class=&quot;menuLink&quot;&gt; &lt;van-icon :name=&quot;item.icon&quot; :class-prefix=&quot;item.classPrefix&quot; style=&quot;margin: 0px 10px 0px 0px&quot; /&gt; &#123;&#123; item.text &#125;&#125; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.defaultProfile &#123; margin: 30px 0;&#125;.defaultProfile .defaultAvatar &#123; display: flex; flex-direction: column; align-items: center; justify-content: center;&#125;.defaultSection &#123; padding: 20px; background-color: #fff; box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1); display: flex; align-items: center; justify-content: center;&#125;.defaultSection ul &#123; list-style: none; width: 100%; padding: 0; margin: 0;&#125;.defaultSection li &#123; margin: 20px 0px 20px 0px;&#125;.menuLink &#123; display: block; padding: 10px; color: #333; text-decoration: none; border-radius: 5px; background-color: #f6f6f6; box-shadow: 0 0 5px rgba(0, 0, 0, 0.1); display: flex; align-items: center;&#125;.menuLink:hover &#123; background-color: #e6e6e6;&#125;&lt;/style&gt; 个人中心-已登录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;script setup lang=&quot;ts&quot;&gt;const menuItems = [ &#123; icon: &#x27; icon-personal-data&#x27;, classPrefix: &#x27;iconfont&#x27;, text: &#x27;个人资料&#x27;, routerLink: &#x27;/personaldata&#x27; &#125;, &#123; icon: &#x27; icon-permission-application&#x27;, classPrefix: &#x27;iconfont&#x27;, text: &#x27;权限申请&#x27;, routerLink: &#x27;/permissionapplication&#x27; &#125;, &#123; icon: &#x27; icon-operating-guide&#x27;, classPrefix: &#x27;iconfont&#x27;, text: &#x27;使用指南&#x27;, routerLink: &#x27;/operatingguide&#x27; &#125;, &#123; icon: &#x27; icon-setting&#x27;, classPrefix: &#x27;iconfont&#x27;, text: &#x27;设置&#x27;, routerLink: &#x27;/setting&#x27; &#125;]// 用户名【应当通过企业微信登录之后来确定】const username = &#x27;帅哥/美女&#x27;// 设置问候语const greeting = computed(() =&gt; &#123; const hour = new Date().getHours() if (hour &gt;= 6 &amp;&amp; hour &lt; 11) &#123; return `早上好, $&#123;username&#125;` &#125; else if (hour &gt;= 11 &amp;&amp; hour &lt; 13) &#123; return `中午好, $&#123;username&#125;` &#125; else if (hour &gt;= 13 &amp;&amp; hour &lt; 18) &#123; return `下午好, $&#123;username&#125;` &#125; else &#123; return `晚上好, $&#123;username&#125;` &#125;&#125;)&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;defaultProfile&quot;&gt; &lt;div class=&quot;defaultAvatar&quot;&gt; &lt;van-icon name=&quot; icon-volunteer-avatar&quot; class-prefix=&quot;iconfont&quot; size=&quot;80&quot; /&gt; &lt;div class=&quot;defaultText&quot;&gt;&#123;&#123; greeting &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;defaultSection&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in menuItems&quot; :key=&quot;item.text&quot;&gt; &lt;router-link :to=&quot;item.routerLink&quot; class=&quot;menuLink&quot;&gt; &lt;van-icon :name=&quot;item.icon&quot; :class-prefix=&quot;item.classPrefix&quot; style=&quot;margin: 0px 10px 0px 0px&quot; /&gt; &#123;&#123; item.text &#125;&#125; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.defaultProfile &#123; margin: 30px 0;&#125;.defaultProfile .defaultAvatar &#123; display: flex; flex-direction: column; align-items: center; justify-content: center;&#125;.defaultSection &#123; padding: 20px; background-color: #fff; box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1); display: flex; align-items: center; justify-content: center;&#125;.defaultSection ul &#123; list-style: none; width: 100%; padding: 0; margin: 0;&#125;.defaultSection li &#123; margin: 20px 0px 20px 0px;&#125;.menuLink &#123; display: block; padding: 10px; color: #333; text-decoration: none; border-radius: 5px; background-color: #f6f6f6; box-shadow: 0 0 5px rgba(0, 0, 0, 0.1); display: flex; align-items: center;&#125;.menuLink:hover &#123; background-color: #e6e6e6;&#125;&lt;/style&gt; 个人中心功能-个人资料页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;script setup lang=&quot;ts&quot;&gt;// 用户的个人信息const userInfo = ref(&#123; avatar: &#x27;&#x27;, // 用户头像 username: &#x27;用户名&#x27;, realName: &#x27;张三&#x27;, // 真实姓名，不能修改 studentId: &#x27;20230001&#x27;, // 学号，不能修改 phone: &#x27;12345678901&#x27;, email: &#x27;example@example.com&#x27;, bio: &#x27;这是我的个人简介。&#x27;, gender: 0 // 性别：0 = 不填写，1 = 男，2 = 女&#125;)const isEditing = ref(false) // 标记是否处于编辑模式// 进入编辑模式const startEditing = () =&gt; &#123; isEditing.value = true&#125;// 提交修改const saveChanges = () =&gt; &#123; isEditing.value = false&#125;// 上传头像const uploadAvatar = (e: Event) =&gt; &#123; const file = (e.target as HTMLInputElement).files?.[0] if (file) &#123; userInfo.value.avatar = URL.createObjectURL(file) showToast(&#x27;头像上传成功&#x27;) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;van-nav-bar title=&quot;个人资料&quot; fixed placeholder /&gt; &lt;!-- 头像部分 --&gt; &lt;div style=&quot;text-align: center; margin: 20px 0&quot;&gt; &lt;label for=&quot;avatar-upload&quot; style=&quot;cursor: pointer&quot;&gt; &lt;img :src=&quot;userInfo.avatar || &#x27;https://via.placeholder.com/80&#x27;&quot; alt=&quot;avatar&quot; style=&quot;width: 80px; height: 80px; border-radius: 50%&quot; /&gt; &lt;/label&gt; &lt;!-- 当处于编辑模式时才显示提示 --&gt; &lt;p v-if=&quot;isEditing&quot;&gt;点击头像修改&lt;/p&gt; &lt;input :disabled=&quot;!isEditing&quot; id=&quot;avatar-upload&quot; type=&quot;file&quot; accept=&quot;image/*&quot; style=&quot;display: none&quot; @change=&quot;uploadAvatar&quot; /&gt; &lt;/div&gt; &lt;!-- 个人信息部分 --&gt; &lt;van-cell-group&gt; &lt;!-- 用户名 --&gt; &lt;van-field v-model=&quot;userInfo.username&quot; label=&quot;用户名&quot; :disabled=&quot;!isEditing&quot; :input-align=&quot;&#x27;left&#x27;&quot; /&gt; &lt;!-- 真实姓名（不可修改） --&gt; &lt;van-field v-model=&quot;userInfo.realName&quot; label=&quot;真实姓名&quot; :disabled=&quot;true&quot; :input-align=&quot;&#x27;left&#x27;&quot; :class=&quot;isEditing ? &#x27;disabled-field&#x27; : &#x27;&#x27;&quot; /&gt; &lt;!-- 学号（不可修改） --&gt; &lt;van-field v-model=&quot;userInfo.studentId&quot; label=&quot;学号&quot; :disabled=&quot;true&quot; :input-align=&quot;&#x27;left&#x27;&quot; :class=&quot;isEditing ? &#x27;disabled-field&#x27; : &#x27;&#x27;&quot; /&gt; &lt;!-- 手机号 --&gt; &lt;van-field v-model=&quot;userInfo.phone&quot; label=&quot;手机号&quot; :disabled=&quot;!isEditing&quot; :input-align=&quot;&#x27;left&#x27;&quot; /&gt; &lt;!-- 邮箱 --&gt; &lt;van-field v-model=&quot;userInfo.email&quot; label=&quot;邮箱&quot; :disabled=&quot;!isEditing&quot; :input-align=&quot;&#x27;left&#x27;&quot; /&gt; &lt;!-- 性别 --&gt; &lt;van-field label=&quot;性别&quot; :disabled=&quot;!isEditing&quot; :input-align=&quot;&#x27;left&#x27;&quot;&gt; &lt;template #input&gt; &lt;van-radio-group :disabled=&quot;!isEditing&quot; v-model=&quot;userInfo.gender&quot; direction=&quot;horizontal&quot; &gt; &lt;van-radio name=&quot;1&quot;&gt;男&lt;/van-radio&gt; &lt;van-radio name=&quot;2&quot;&gt;女&lt;/van-radio&gt; &lt;van-radio name=&quot;0&quot;&gt;保密&lt;/van-radio&gt; &lt;/van-radio-group&gt; &lt;/template&gt; &lt;/van-field&gt; &lt;!-- 个人简介 --&gt; &lt;van-field v-model=&quot;userInfo.bio&quot; label=&quot;个人简介&quot; type=&quot;textarea&quot; rows=&quot;3&quot; :autosize=&quot;&#123; maxHeight: 100 &#125;&quot; maxlength=&quot;150&quot; placeholder=&quot;请输入个人简介&quot; show-word-limit :disabled=&quot;!isEditing&quot; /&gt; &lt;/van-cell-group&gt; &lt;!-- 编辑按钮 --&gt; &lt;div style=&quot;margin: 16px&quot;&gt; &lt;van-button v-if=&quot;!isEditing&quot; type=&quot;primary&quot; block @click=&quot;startEditing&quot;&gt; 修改个人信息 &lt;/van-button&gt; &lt;van-button v-else type=&quot;success&quot; block @click=&quot;saveChanges&quot;&gt; 保存修改 &lt;/van-button&gt; &lt;/div&gt; &lt;Divider dividerText=&quot;人工智能学院 “小红帽”常青藤青年志愿者服务队&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.disabled-field input &#123; background-color: #f5f5f5; color: #aaa;&#125;&lt;/style&gt; 个人中心功能-权限申请页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;script setup lang=&quot;ts&quot;&gt;// 通知消息const notification = ref&lt;string&gt;( &#x27;目前只支持青队成员可以申请权限哦~后续也会为普通用户提供权限福利！&#x27;)// 表单数据const username = ref&lt;string&gt;(&#x27;&#x27;)const studentId = ref&lt;string&gt;(&#x27;&#x27;)const reson = ref&lt;string&gt;(&#x27;&#x27;)const right = ref(&#x27;&#x27;)const showPicker = ref(false)const right_columns = [ &#123; text: &#x27;超级管理员&#x27;, value: &#x27;1&#x27; &#125;, &#123; text: &#x27;管理员&#x27;, value: &#x27;2&#x27; &#125;]const onConfirm = (&#123; selectedOptions &#125;) =&gt; &#123; right.value = selectedOptions[0]?.text showPicker.value = false&#125;// 验证规则const rules = &#123; username: [&#123; required: true, message: &#x27;姓名不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;], studentId: [ &#123; required: true, message: &#x27;学号不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;, &#123; pattern: /^\\d&#123;8,12&#125;$/, message: &#x27;学号格式不正确&#x27;, trigger: &#x27;onBlur&#x27; &#125; // 学号假设为8到12位数字 ], right: [&#123; required: true, message: &#x27;请选择要申请的权限&#x27;, trigger: &#x27;onBlur&#x27; &#125;], reson: [&#123; required: true, message: &#x27;申请原因不能为空&#x27;, trigger: &#x27;onBlur&#x27; &#125;]&#125;// 提交处理const onSubmit = () =&gt; &#123; showToast(&#x27;提交成功&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 小公告 --&gt; &lt;HomeNoticeBar :notification=&quot;notification&quot; /&gt; &lt;!-- 队徽队名 --&gt; &lt;HomeTeamName /&gt; &lt;van-form @submit=&quot;onSubmit&quot;&gt; &lt;van-cell-group inset&gt; &lt;!-- 姓名 --&gt; &lt;van-field v-model=&quot;username&quot; :rules=&quot;rules.username&quot; :required=&quot;rules.username[0].required&quot; label=&quot;姓名&quot; placeholder=&quot;请输入您的姓名&quot; /&gt; &lt;!-- 学号 --&gt; &lt;van-field v-model=&quot;studentId&quot; :rules=&quot;rules.studentId&quot; :required=&quot;rules.studentId[0].required&quot; label=&quot;学号&quot; placeholder=&quot;请输入您的学号&quot; /&gt; &lt;!-- 申请权限 --&gt; &lt;van-field v-model=&quot;right&quot; :rules=&quot;rules.right&quot; :required=&quot;rules.right[0].required&quot; is-link readonly name=&quot;picker&quot; label=&quot;选择器&quot; placeholder=&quot;点击选择权限&quot; @click=&quot;showPicker = true&quot; /&gt; &lt;van-popup v-model:show=&quot;showPicker&quot; position=&quot;top&quot;&gt; &lt;van-picker :columns=&quot;right_columns&quot; @confirm=&quot;onConfirm&quot; @cancel=&quot;showPicker = false&quot; /&gt; &lt;/van-popup&gt; &lt;!-- 申请原因 --&gt; &lt;van-field v-model=&quot;reson&quot; :rules=&quot;rules.reson&quot; :required=&quot;rules.reson[0].required&quot; rows=&quot;2&quot; autosize label=&quot;申请原因&quot; type=&quot;textarea&quot; maxlength=&quot;1000&quot; placeholder=&quot;请输入申请原因&quot; show-word-limit /&gt; &lt;/van-cell-group&gt; &lt;div style=&quot;margin: 16px&quot;&gt; &lt;van-button round block type=&quot;primary&quot; native-type=&quot;submit&quot;&gt; 提交 &lt;/van-button&gt; &lt;/div&gt; &lt;/van-form&gt; &lt;Divider dividerText=&quot;人工智能学院 “小红帽”常青藤青年志愿者服务队&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 个人中心功能-使用指南页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;script setup lang=&quot;ts&quot;&gt;const activeName = ref&lt;string&gt;(&#x27;1&#x27;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;van-nav-bar title=&quot;使用指南&quot; fixed placeholder /&gt; &lt;van-collapse v-model=&quot;activeName&quot; accordion&gt; &lt;!-- 登录账户指南 --&gt; &lt;van-collapse-item title=&quot;步骤 1: 登录账户&quot; name=&quot;1&quot; :title-style=&quot;&#123; color: activeName === &#x27;1&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 使用注册时的手机号或邮箱进行登录，未注册用户请先注册。登录后可以访问所有功能。 &lt;/van-collapse-item&gt; &lt;!-- 查看通知指南 --&gt; &lt;van-collapse-item title=&quot;步骤 2: 查看通知&quot; name=&quot;2&quot; :title-style=&quot;&#123; color: activeName === &#x27;2&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 登录后可以在通知页面查看最新的公告和通知，保持信息的及时获取。 &lt;/van-collapse-item&gt; &lt;!-- 提交反馈指南 --&gt; &lt;van-collapse-item title=&quot;步骤 3: 提交反馈&quot; name=&quot;3&quot; :title-style=&quot;&#123; color: activeName === &#x27;3&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 在反馈页面填写您的意见和建议，支持匿名提交，帮助我们改进服务。 &lt;/van-collapse-item&gt; &lt;!-- 修改个人信息指南 --&gt; &lt;van-collapse-item title=&quot;步骤 4: 修改个人信息&quot; name=&quot;4&quot; :title-style=&quot;&#123; color: activeName === &#x27;4&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 您可以在个人中心修改头像、昵称和联系方式等信息，以确保个人资料的准确性。 &lt;/van-collapse-item&gt; &lt;!-- 常见问题指南 --&gt; &lt;van-collapse-item title=&quot;常见问题&quot; name=&quot;5&quot; :title-style=&quot;&#123; color: activeName === &#x27;5&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 在常见问题页面，我们整理了一些常见的使用疑问及解答，供您参考。 &lt;/van-collapse-item&gt; &lt;!-- 联系客服指南 --&gt; &lt;van-collapse-item title=&quot;联系客服&quot; name=&quot;6&quot; :title-style=&quot;&#123; color: activeName === &#x27;6&#x27; ? &#x27;#1989fa&#x27; : &#x27;#000&#x27; &#125;&quot; &gt; 如果遇到问题无法解决，您可以通过联系客服功能与我们取得联系。 &lt;/van-collapse-item&gt; &lt;/van-collapse&gt; &lt;Divider dividerText=&quot;人工智能学院 “小红帽”常青藤青年志愿者服务队&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 个人中心功能-设置页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;script setup lang=&quot;ts&quot;&gt;const router = useRouter()// 退出登录函数const logout = () =&gt; &#123; // 模拟退出登录逻辑，可以在这里处理实际的退出登录操作 showSuccessToast(&#123; message: &#x27;已退出登录&#x27;, position: &#x27;top&#x27; &#125;) router.push(&#x27;/&#x27;)&#125;// 处理其他设置项点击事件const handleSettingClick = (message: string) =&gt; &#123; showToast(&#123; message: message, position: &#x27;top&#x27; &#125;)&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;van-nav-bar title=&quot;设置&quot; fixed placeholder /&gt; &lt;!-- 设置选项 --&gt; &lt;van-cell-group&gt; &lt;!-- 修改密码 --&gt; &lt;van-cell title=&quot;修改密码&quot; is-link @click=&quot;handleSettingClick(&#x27;修改密码功能正在开发中...&#x27;)&quot; /&gt; &lt;!-- 通知设置 --&gt; &lt;van-cell title=&quot;通知设置&quot; is-link @click=&quot;handleSettingClick(&#x27;通知设置功能正在开发中...&#x27;)&quot; /&gt; &lt;!-- 隐私设置 --&gt; &lt;van-cell title=&quot;隐私设置&quot; is-link @click=&quot;handleSettingClick(&#x27;隐私设置功能正在开发中...&#x27;)&quot; /&gt; &lt;/van-cell-group&gt; &lt;!-- 退出登录按钮 --&gt; &lt;div style=&quot;margin: 16px&quot;&gt; &lt;van-button type=&quot;danger&quot; block @click=&quot;logout&quot;&gt; 退出登录 &lt;/van-button&gt; &lt;/div&gt; &lt;Divider dividerText=&quot;人工智能学院 “小红帽”常青藤青年志愿者服务队&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 组件-底线1234567891011121314151617181920212223/* components/Divider/index.vue */&lt;script setup lang=&quot;ts&quot;&gt;// 使用类型声明来定义 Props 类型interface Props &#123; dividerText?: string // 让 dividerText 成为可选的&#125;// 使用 defineProps 来定义组件的 PropsdefineProps&lt;Props&gt;()&lt;/script&gt;&lt;template&gt; &lt;van-divider class=&quot;divider&quot;&gt; &#123;&#123; dividerText &#125;&#125; &lt;/van-divider&gt;&lt;/template&gt;&lt;style scoped&gt;.divider &#123; margin: 20px 0px 20px 0px; padding: 0px 10px 0px 10px;&#125;&lt;/style&gt; 后端开发 controllers 文件夹 作用：存放业务逻辑处理函数。每个控制器负责处理特定路由的请求，调用相应的 service 来执行操作，然后将响应返回给客户端。 添加内容：为每个实体或模块创建一个控制器文件，包含增、删、改、查等操作。例如：userController.ts 处理用户相关的请求。 db 文件夹 作用：存放数据库连接配置和数据库操作相关的代码。你可以在这里创建数据库连接池和处理数据库查询。 添加内容：创建 index.ts 文件，用来管理数据库连接（如 MySQL）。还可以根据需求创建数据库查询方法。 middlewares 文件夹 作用：存放中间件，用于处理路由请求前的一些公共操作，如验证、日志、错误处理等。 添加内容：添加常见的中间件文件，如 authMiddleware.ts（用于认证）和 errorMiddleware.ts（用于统一错误处理）。 routers 文件夹 作用：存放路由定义，指定哪些 URL 对应哪些控制器的操作。 添加内容：为每个模块创建一个路由文件，例如 userRouter.ts。使用 express.Router() 来定义路由，并导入相应的控制器方法。 services 文件夹 作用：负责处理业务逻辑和数据操作，主要与 db 层进行交互。service 层让控制器和数据库逻辑分离，使得代码结构更加清晰。 添加内容：为每个实体创建服务文件，例如 userService.ts，负责用户的增删改查逻辑。 types 文件夹 作用：存放 TypeScript 类型定义。你可以在这里定义全局的接口、类型等。 添加内容：例如 user.d.ts 用于定义用户实体的类型，或者定义 responseFormat.ts 用于标准化 API 响应结构的类型。 utils 文件夹 作用：存放通用的工具函数或辅助功能，例如加密函数、格式化工具、日志工具等。 添加内容：比如创建一个 responseHandler.ts，封装和优化 res.send() 的响应格式，使其可以统一处理成功或失败的请求。 创建后端项目初始化npm项目 1npm init -y 安装express框架 1npm i express 安装依赖与ts有关的依赖：express是基于node环境的，所以我们需要安装两个类型依赖，以获得相关api的类型提示 1npm install typescript ts-node @types/node @types/express --save-dev 初始化 TypeScript 配置：执行以下命令来生成 tsconfig.json 文件： 1tsc --init tsconfig.json 文件中的配置： 123456789101112131415161718&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es2016&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;esModuleInterop&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;strict&quot;: true, &quot;skipLibCheck&quot;: true, &quot;rootDir&quot;: &quot;./src&quot;, &quot;outDir&quot;: &quot;./dist&quot;, &#125;, &quot;include&quot;: [ &quot;src/**/*&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot; ]&#125; 项目入口文件创建项目入口文件：在 src 目录下创建 app.ts 文件： 1234567891011// 导入 express 模块const express = require(&#x27;express&#x27;)// 创建 express 的服务器实例const app = express()// write your code here...// 调用 app.listen 方法，指定端口号并启动web服务器app.listen(3007, function () &#123; console.log(&#x27;api server running at http://127.0.0.1:3007&#x27;)&#125;) 配置 cors 跨域安装cors中间件 1npm i cors 在app.js中配置cors中间件 1234// 导入 cors 中间件const cors = require(&#x27;cors&#x27;)// 将 cors 注册为全局中间件app.use(cors()) 配置解析表单数据的中间件配置解析 JSON 和 application&#x2F;x-www-form-urlencoded 格式的表单数据的中间件： 123// 配置解析表单数据的中间件app.use(express.json())app.use(express.urlencoded(&#123; extended: false &#125;)) 配置路由创建routers、controllers、services三大文件夹 routers：index.ts文件统一管理所有模块的路由；其他均为模块单独的路由管理 controllers：每个模块的管理端代码，放置请求的整体代码 services：每个模块的服务端代码，放置具体的请求内容和实现逻辑 封装统一的响应格式新建/utils/responseUtil.ts文件，在此封装统一响应格式： 12345678910111213141516171819202122232425// 封装统一的响应格式import &#123; Response &#125; from &#x27;express&#x27;;interface ResponseFormat &#123; success: boolean; message: string; data?: any;&#125;export const successResponse = (res: Response, data: any, message = &#x27;Success&#x27;, statusCode = 200) =&gt; &#123; const response: ResponseFormat = &#123; success: true, message, data &#125;; res.status(statusCode).json(response);&#125;;export const errorResponse = (res: Response, message: string, statusCode = 500) =&gt; &#123; const response: ResponseFormat = &#123; success: false, message &#125;; res.status(statusCode).json(response);&#125;; 安装并配置 mysql 模块运行如下命令，安装 mysql 模块： 12npm i mysqlnpm install @types/mysql --save-dev 新建 /db/index.js 文件，在此自定义模块中创建数据库的连接对象： 12345678910111213141516171819202122import mysql from &#x27;mysql&#x27;;const db = mysql.createPool(&#123; host: &#x27;127.0.0.1&#x27;, user: &#x27;root&#x27;, password: &#x27;Hu1282861514&#x27;, database: &#x27;cqt_cloud_platform&#x27;&#125;);// 封装 db.query 为 Promiseexport const query = &lt;T&gt;(sql: string, values?: any): Promise&lt;T&gt; =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; db.query(sql, values, (error, results) =&gt; &#123; if (error) &#123; return reject(error); &#125; resolve(results); &#125;); &#125;);&#125;;export default db; 配置中间件创建middlewares文件夹，放置使用的中间件 表单验证中间件（validateInput.ts） 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; Request, Response, NextFunction &#125; from &#x27;express&#x27;;const studentIdRegex = /^\\d&#123;10&#125;$/; // 正则表达式用于验证学号const emailRegex = /^[a-zA-Z0-9._%+-]+@ctbu\\.edu\\.cn$/; // 正则表达式用于验证邮箱export const validateRegistration = (req: Request, res: Response, next: NextFunction): void =&gt; &#123; const &#123; student_id, email, password &#125; = req.body; if (!student_id || !studentIdRegex.test(student_id)) &#123; res.status(400).json(&#123; message: &#x27;学号必须为10位数字&#x27; &#125;); return; &#125; if (!email || !email.endsWith(&#x27;@ctbu.edu.cn&#x27;)) &#123; res.status(400).json(&#123; message: &#x27;邮箱必须以 @ctbu.edu.cn 结尾&#x27; &#125;); return; &#125; if (!password || password.length &lt; 6 || !/[A-Z]/.test(password) || !/[a-z]/.test(password) || !/\\d/.test(password)) &#123; res.status(400).json(&#123; message: &#x27;密码长度至少为6位，并且包含大小写字母和数字&#x27; &#125;); return; &#125; // 如果验证通过，调用 next() next();&#125;;export const validateLogin = (req: Request, res: Response, next: NextFunction): void =&gt; &#123; const &#123; loginInput, password &#125; = req.body; // 检查是否输入了学号或邮箱 if (!loginInput || (!studentIdRegex.test(loginInput) &amp;&amp; !emailRegex.test(loginInput))) &#123; res.status(400).json(&#123; message: &#x27;学号或邮箱格式错误&#x27; &#125;); return; &#125; // 检查是否输入了密码 if (!password) &#123; res.status(400).json(&#123; message: &#x27;密码不能为空&#x27; &#125;); return; &#125; // 如果验证通过，调用 next() next();&#125;; 安装密码加密库 (bcrypt) 和 JWT 库123npm install bcrypt jsonwebtokennpm install @types/bcrypt --save-devnpm install @types/jsonwebtoken --save-dev bcrypt: 用于密码哈希和验证。 jsonwebtoken: 用于生成和验证 JWT。 @types/bcrypt: bcrypt 的 TypeScript 类型定义。 @types/jsonwebtoken: JWT 的 TypeScript 类型定义。 用户注册逻辑注意事项及问题解决开发环境准备本项目开发建议使用下方的开发软件，请提前配置好下方所示的开发环境 开发软件：VS Code，微信开发者工具 开发环境依赖： node：18.17.0 npm：10.8.2 pnpm：9.1.0 ts-node：10.9.2 nodemon：3.1.0 导入vue文件TS报错错误信息提示： TypeScript 无法找到模块 @/views/**/**.vue 的声明文件，这意味着 TypeScript 无法推断该文件的类型，因此默认将其视为 any 类型。 原因：TypeScript 默认不支持 .vue 文件的模块类型解析，需要手动添加类型声明文件。 解决方法： 12345678/* env.d.ts *//// &lt;reference types=&quot;vite/client&quot; /&gt;declare module &#x27;*.vue&#x27; &#123; import type &#123; DefineComponent &#125; from &#x27;vue&#x27; // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types const component: DefineComponent&lt;&#123;&#125;, &#123;&#125;, any&gt; export default component&#125;","categories":[],"tags":[]},{"title":"暑假学习","slug":"暑假学习","date":"2024-08-02T06:22:19.784Z","updated":"2024-10-07T15:47:03.191Z","comments":true,"path":"2024/08/02/暑假学习/","permalink":"http://eastyn7.github.io/2024/08/02/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"TypeScriptJS已有的类型 原始类型：number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol 对象类型：object（数组、对象、函数等对象） TS新增的类型 联合类型、自定义类型（类型别名）、接口、元祖、字面量类型、枚举、void、any等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 原始类型let age: number = 18let myName: string = &#x27;eee&#x27;let isLoading: boolean = truelet a: null = nulllet b: undefined = undefinedlet s: symbol = Symbol()// 对象类型let numbers: number[] = [1,2,3]let strings: string[] = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]let strings: Array&lt;string&gt; = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]// 联合类型let arr: (number | string)[] = [&#x27;1&#x27;,1,&#x27;2&#x27;,2,&#x27;3&#x27;,3]// 类型别名type CustomArray = (number | string)[]let arr1: CustomArray = [&#x27;1&#x27;,1,&#x27;2&#x27;,2,&#x27;3&#x27;,3]// 函数类型function add(num1: number, num2: number): number &#123; return num1 + num2&#125;const add = (num1: number, num2: number): number =&gt; &#123; return num1 + num2&#125;const add: (num1: number, num2: number) =&gt; number = (num1, num2) =&gt; &#123; return num1 + num2&#125;function greet(name: string): void &#123; console.log(&#x27;Hello&#x27;, name)&#125;// 可选参数function mySlice(start?: number, end?: number): void &#123; console.log(&#x27;起始索引：&#x27;, start, &#x27;结束索引：&#x27;, end)&#125;// 对象类型let person: &#123; name: string; age: number; &#125;// 接口interface IPerson &#123; name: string age: number sayHi(): void&#125;let person: IPerson = &#123; name: &#x27;Jack&#x27;, age: 19, sayHi() &#123;&#125;&#125;/*接口与类型别名的对比：相同点：都可以给对象指定类型不同点：接口只能为对象指定类型；类型别名不仅可以为对象指定类型，实际上可以为任意类型指定别名*/type IPerson = &#123; name: string age: number sayHi(): void&#125;type NumStr = number |string// 接口的继承interface Point2D &#123; x: number; y: number &#125;interface Point3D extends Point2D &#123; z: number &#125;// 元组let position: [number, number] = [0.11, 0.22]// 类型断言const aLink: HTMLAnchorElementconst aLink = document.getElementByID(&#x27;link&#x27;) as HTMLAnchorElement// const aLink = &lt;HTMLAnchorElement&gt;document.getELementById(&#x27;link&#x27;)【不常用，跟react有冲突】// 字面量类型let str1 = &#x27;Hello TS&#x27; // string；let声明变量const str2 = &#x27;Hello TS&#x27; // &quot;Hello TS&quot;；const声明常量// 用来表示一组明确的可选值列表function changeDirection(directin: &#x27;up&#x27; | &#x27;down&#x27; | &#x27;left&#x27; | &#x27;right&#x27;)&#123; console.log(direction)&#125;// 枚举(enum)enum Direction &#123; Up, Down, Left, Right &#125;function changeDirection(directin: Direction)&#123; console.log(direction)&#125;changeDirection(Direction.Left)/*枚举成员的值默认第一个为0依次增加，也可以自定义值【默认数字，也可以为字符串】enum Direction &#123; Up = 10, Down, Left, Right &#125;enum Direction &#123; Up = 2, Down = 4, Left = 8, Right = 16 &#125;*/// 字符串枚举enum Direction &#123; Up = &#x27;UP&#x27;, Down = &#x27;DOWN&#x27;, Left = &#x27;LEFT&#x27;, Right = &#x27;RIGHT&#x27; &#125;// any类型let obj: any = &#123; x: 0 &#125;// typeofconsole.log(typeof &quot;Hello world&quot;)// 根据类型上下文来let p = &#123; x: 1, y: 2 &#125;function formatPoint(point: &#123; x: number; y: number&#125;)&#123;&#125;formatPoint(p)function formatPoint(point: typeof p) TS高级类型 class类、类型兼容性、交叉类型、泛型和keyof、索引签名类型和索引查询类型、映射类型等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// class类class Person&#123; age: number // gender: &#x27;男&#x27; gender: string x = 10 y = 10 // 构造函数 constructor(age: number, gender: string)&#123; this.age = age this.gender = gender &#125; // 实例方法 scale(n: number): void &#123; this.x *= n this.y *= n &#125;&#125;const p = new Person()p.age// 类继承class Animal &#123; move() &#123; console.log(&#x27;Moving along!&#x27;) &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log(&#x27;wang!&#x27;) &#125;&#125;const dog = new Dog()// 接口interface Singable &#123; sing(): void&#125;class Person implements Singable &#123; sing() &#123; console.log(&#x27;asdfadf&#x27;) &#125;&#125;// 修饰符publicprotectedprivatereadonly：表示只读，只能被构造函数进行赋值// 类型兼容性对象兼容：成员多的赋值给成员少的接口兼容：多的赋值给少的函数兼容：参数个数少的赋值给参数个数多的；参数类型对应一致；返回值多的赋值给少的// 交叉类型（&amp;）interface Person &#123; name: string &#125;interface Contact &#123; phone: string &#125;type PersonDetail = Person &amp; Contactlet obj = PersonDetail = &#123; name: &#x27;Jack&#x27;, phone: &#x27;123...&#x27;&#125;/*交叉类型和接口继承的对比相同点：都可以实现对象类型的组合不同点：两种方式实现类型组合时，对于同名属性之间，处理类型冲突的方式不同。继承会报错但是交叉类型不会interface A &#123; fn: (value: number) =&gt; string&#125;interface B extends A &#123; fn: (value: string) =&gt; string&#125;这里是错误的interface A &#123; fn: (value: number) =&gt; string&#125;interface B &#123; fn: (value: string) =&gt; string&#125;type C = A &amp; B 相当于 在C中fn: (value: string | number) =&gt; string*/// 泛型function id&lt;Type&gt;(value: Type): Type &#123; return value &#125;const num = id&lt;number&gt;(10) // 此时num的类型即为numberconst str = id&lt;string&gt;(&#x27;str&#x27;) // 此时str的类型即为stringlet num = id(10) // 可以简化不用写&lt;&gt;，会推断为字面量类型// 泛型约束/*指定更加具体的类型*/function id&lt;Type&gt;(value: Type[]): Type[] &#123; console.log(value.length) return value&#125;/*添加约束*//*只要有length属性就可以*/interface ILength &#123; length: number &#125;function id&lt;Type extedns ILength&gt;(value: Type): Type &#123; console.log(value.length) return value&#125;// 多个泛型变量的情况function getProp&lt;Type, Key extends keyof Type&gt;(obj: Type, key: Key)&#123; return obj[key]&#125;let person = &#123; name: &#x27;Jack&#x27;, age: 18 &#125;getProp(person, &#x27;name&#x27;)// 泛型接口interface IdFunc&lt;Type&gt; &#123; id: (value: Type) =&gt; Type ids: () =&gt; Type[]&#125;let obj: IdFunc&lt;number&gt; &#123; id(value) &#123; return value &#125;, ids() &#123; return [1, 3, 5] &#125;&#125;// 泛型类class GenericNumber&lt;NumType&gt; &#123; defaultValue: NumType add: (x: NumType, y: NumType) =&gt; NumType&#125;const myNum = new GenericNumber&lt;number&gt;()// 泛型工具类型（Partial）/*构造出来的新类型PartialProps结构和Props相同，但所有属性都变为是可选的*/interface Props &#123; id: string children: number[]&#125;type PartialProps = Partial&lt;Props&gt;// 泛型工具类型（Readonly）/*构造一个所有属性为只读的类型*/interface Props &#123; id: string children: number[]&#125;type ReadonlyProps = Readonly&lt;Props&gt;// 泛型工具类型（Pick）/*Pick&lt;Type,Keys&gt;从Type中选择一组属性来构造新类型*/interface Props &#123; id: string title: string children: number[]&#125;type PickProps = Pick&lt;Props, &#x27;id&#x27; | &#x27;title&#x27;&gt;// 泛型工具类型（Record）/*Record&lt;Keys,Type&gt;构造一个新对象类型，属性键为Keys，属性类型为Type*/type RecordObj = Record&lt;&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;, string[]&gt;let obj: RecordObj = &#123; a: [&#x27;1&#x27;], b: [&#x27;2&#x27;], c: [&#x27;3&#x27;]&#125;// 索引签名类型interface AnyObject &#123; [key: steing]: number&#125;let obj: AnyObject = &#123; a: 1, b: 2&#125; // 映射类型/*基于旧类型创建新类型，只能在类型别名中使用*/type PropKeys = &#x27;x&#x27; | &#x27;y&#x27; | &#x27;z&#x27;type Type = &#123; [Key in PropKeys]: number &#125;type Props = &#123; a: number; b: string; c: boolean &#125;type Type = &#123; [Key in keyof Props]: number &#125;// 索引查询类型/*T[P]语法用来查询属性的类型*/type Props = &#123; a: number; b: string; c: boolean &#125;type TypeA = Props[&#x27;a&#x27;]//numbertype TypeA = Props[&#x27;a&#x27; | &#x27;b&#x27;]//number|stringtype TypeA = Props[keyof Props]//number|string|boolean TS中的文件类型 .ts文件 既包含类型信息又可执行代码 可以被编译为.js文件然后执行 用途：编写程序代码的地方 .d.ts文件（类似于C++中的头文件） 只包含类型信息的类型声明文件 不会生成.js文件，仅用于提供类型信息 用途：为js提供类型信息 //为js文件提供类型声明 /* 在js文件中已存在如下的内容 let count = 10 let songName = &#39;痴心绝对&#39; let position = &#123; x: 0, y: 0 &#125; function add(x,y) &#123; retrun x+y &#125; function changeDirection(direction)&#123; console.log(direction) &#125; const fomartPoint = point =&gt; &#123; console.log(&#39;当前坐标:&#39;, point) &#125; export &#123;count, songName, position, add, changeDirection&#125; */ declare let count: number declare let someName: string interface Point &#123; x: number y: number &#125; declare let positon: Point declare function add(x: mumber, y: number): number declare function changeDirection(direction: &#39;up&#39;|&#39;down&#39;|&#39;left&#39;|&#39;right&#39;):void type FomartPoint = (point: Point) =&gt; void declare const fomartPoint: FomartPoint // declare const fomartPoint: (point: Point) =&gt; void export &#123;count, songName, position, add, changeDirection&#125; SSMSpring1.Spring Framework系统架构 Core Container : 核心容器 AOP : 面向切面编程 Aspects : AOP思想实现 Data Access : 数据访问 Data Integration : 数据集成 Web : Web开发 Test : 单元测试与集成测试 IoC（Inversion of Control）控制反转：使用对象事，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转 Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的“外部” IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean DI（Dependency Injection）依赖注入：在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入 2.bean 类别 描述 名称 bean 类型 标签 所属 beans标签 格式 属性列表 id：bean的id，使用容器可以通过id值获取对应的bean，在一个容器中id值唯一class：bean的类型，即配置的bean的全路径类名name：bean的别名，可以有多名称，空格分开scope：bean的作用范围，可以控制创建实例的数量，是否是单例的对象，可选范围【singleton（单例默认）、prototype（非单例）】init-method：bean初始化方法destroy-method：bean的销毁方法 范例 实例化 构造函数：使用静态工厂：使用实例工厂： 生命周期 阶段：1、初始化容器：①创建对象（内存分配）②执行构造方法③执行属性注入（set操作）④执行bean初始化方法2、使用bean：①执行业务操作3、关闭&#x2F;销毁容器：①执行bean销毁方法pbulic class BookDaoImpl implements BookDao { &#x2F;&#x2F; 表示bean初始化对应的操作 public void init(){ System.out.println(“init…”) } &#x2F;&#x2F; 表示bean销毁前对应的操作 【 需要关闭容器： ①手工关闭容器：ConfigurableApplicationContext接口close()操作 ②注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机：ConfigurableApplicationContext接口registerShutdownHook()操作 】 public void destory{ System.out.println(“destory…”) }}&#x2F;&#x2F; 需要在配置文件中进行配置【也可以使用接口控制生命周期，InitializingBean，DisposableBean接口】 3.依赖注入 setter注入 构造器注入 自动装配： 方式：按类型（常用）、按名称、按构造方法、不启用自动装配 4.集合注入","categories":[],"tags":[]},{"title":"Express入门","slug":"express入门","date":"2024-02-22T08:30:19.690Z","updated":"2024-10-07T15:46:52.579Z","comments":true,"path":"2024/02/22/express入门/","permalink":"http://eastyn7.github.io/2024/02/22/express%E5%85%A5%E9%97%A8/","excerpt":"","text":"express入门简介作为前端开发，Nodejs已经成了很多公司对我们这一岗位的硬性要求，而 Express 框架则是其中知名度最高、也是最受欢迎的Nodejs开发框架，它帮助我们封装了Nodejs底层的API，屏蔽了大量的繁琐的细节，让我们只需要关注业务开发就行了，极大的降低了学习的成本。今天这个课程就是教大家去掌握如何使用express去搭建一个简易的后端服务，我们主要围绕以下几个部分： 路由 中间件 静态文件服务 模板引擎 环境准备 电脑 - mac Node - 16.14.2 Npm - 8.5.0 Express - 4.x 第一个demo使用Nodejs内置的http模块搭建服务为了便于大家去理解express对nodejs做了哪些封装，在使用express之前，我们先来看下使用nodejs内置的http模块是怎么搭建node服务的。 首先创建一个express-demo的文件夹并进入 1mkdir express-demo &amp;&amp; cd express-demo 创建server.js，并添加如下代码： 1234567891011const http = require(&#x27;http&#x27;)const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;) res.end(&#x27;hello world&#x27;)&#125;)server.listen(3000, () =&gt; &#123; console.log(&#x27;服务已启动...&#x27;);&#125;) 然后在控制台中运行： 1node server.js 使用express搭建服务接下来，我们再用express搭建服务。 在 express-demo 文件夹下执行 npm init 命令，然后一路回车，就会帮我们创建一个 package.json 文件，然后再执行 npm install express 来安装express模块，然后改写 server.js 。 1234567891011const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;hello world&#x27;)&#125;)app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已启动...&#x27;);&#125;) Request和Response对象 Request对象是请求对象，就是回调函数中的req参数，主要是网络请求中带的一些属性，比如参数, cookie等等。。。 Response对象是响应对象，就是回调函数中的res参数，可以执行一系列的响应操作，比如给客户端响应内容和状态等等。。。 查看Request和Response对象的所有API 路由机制思考：我们在向后端发请求时通过什么去区分接口的？ 答：请求方式+接口url 我们在express中，定义路由的方式是： 1app.METHOD(URL, CALLBACK) 这种方式就可以通过请求方式和URL来帮我们区分不同的请求，从而去执行不同的响应。 nodemonnodemon能够检测工作区代码的变化，并自动重启。 执行 npm install nodemon --save-dev 安装nodemon，然后修改package.json文件中的start命令： 123456789101112131415161718&#123; &quot;name&quot;: &quot;express-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;server.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;nodemon server.js&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.18.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;nodemon&quot;: &quot;^2.0.20&quot; &#125;&#125; 再执行npm start启动服务，之后我们再修改代码就不需要手动的重启服务了。 核心概念路由在浏览器中我们想要访问百度，只需要知道百度的地址就行了，路由也是类似的概念，我们想要知道客户端调用的是哪个接口，就是通过路由来判断的。 路由方法Express 支持对应于 HTTP 方法的以下路由方法：get、post、put、delete等等。使用方法为： 1app.METHOD(URL, CALLBACK) 示例： 1234567891011const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;hello world&#x27;)&#125;)app.post(&#x27;/about&#x27;, (req, res) =&gt; &#123; res.send(&#123; name: &#x27;小明&#x27;, age: 18 &#125;)&#125;) 有一种特殊路由方法：app.all()，该方法用于在所有请求方法的路径中装入中间件函数。 123456app.all(&#x27;/about&#x27;, function(req, res) &#123; res.send(&#123; name: &#x27;jackie&#x27;, age: 18 &#125;)&#125;) 这个示例中不管是get, post方式去请求/about路径的接口，都会经过这个回调函数然后返回对应的数据。 路由路径路由路径可以是字符串、字符串模式或正则表达式。字符串类型的就是我们之前举的那些例子，我们再来看下字符串模式和正则表达式这两种。 以下是基于字符串模式的路由路径的一些示例。 此路由路径将匹配 acd 和 abcd。 123app.get(&#x27;/ab?cd&#x27;, function(req, res) &#123; res.send(&#x27;ab?cd&#x27;);&#125;); 此路由路径将匹配 abcd、abbcd、abbbcd 等。 123app.get(&#x27;/ab+cd&#x27;, function(req, res) &#123; res.send(&#x27;ab+cd&#x27;);&#125;); 此路由路径将匹配 abcd、abxcd、abRABDOMcd、ab123cd 等。 123app.get(&#x27;/ab*cd&#x27;, function(req, res) &#123; res.send(&#x27;ab*cd&#x27;);&#125;); 基于正则表达式的路由路径的示例： 此路由路径将匹配名称中具有“a”的所有路由。 123app.get(/a/, function(req, res) &#123; res.send(&#x27;/a/&#x27;);&#125;); 此路由路径将匹配 butterfly 和 dragonfly，但是不匹配 butterflyman、dragonfly man 等。 123app.get(/.*fly$/, function(req, res) &#123; res.send(&#x27;/.*fly$/&#x27;);&#125;); 路由拆分当我们的路由越来越复杂，比如有用户相关的路径，有系统相关的路径，不统一管理的话会显得特别乱，这个时候，对路由进行拆分是个不错的选择。 拆分前 123456789101112const express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/user/list&#x27;, function(req, res, next)&#123; res.send(&#x27;/list&#x27;);&#125;);app.get(&#x27;/user/detail&#x27;, function(req, res, next)&#123; res.send(&#x27;/detail&#x27;);&#125;);app.listen(3000); 拆分后 12345678910111213141516const express = require(&#x27;express&#x27;);const app = express();const user = express.Router();user.get(&#x27;/list&#x27;, function(req, res, next)&#123; res.send(&#x27;/list&#x27;);&#125;);user.get(&#x27;/detail&#x27;, function(req, res, next)&#123; res.send(&#x27;/detail&#x27;);&#125;);app.use(&#x27;/user&#x27;, user); // 注册user子路由app.listen(3000); 中间件一般学习js的时候，我们都会听到一句话：一切皆函数。而在学习express的过程中，很深的一个感受就是：一切皆中间件。比如常见的请求参数解析、cookie解析、日志打印等，都可以通过中间件来完成。 在 Express 中，中间件就是一个函数： 1234function someMiddleware(req, res, next) &#123; // 自定义逻辑 next();&#125; 三个参数中，req 和 res 就是前面提到的 Request 请求对象和 Response 响应对象；而 next 函数则用来触发下一个中间件的执行。 在 Express 使用中间件有两种方式：全局中间件和路由中间件。 全局中间件通过 app.use 函数就可以注册中间件，并且此中间件会在用户发起任何请求都可能会执行，例如： 1app.use(someMiddleware) 路由中间件通过在路由定义时注册中间件，此中间件只会在用户访问该路由时执行，例如： 123app.get(&#x27;/middleware&#x27;, someMiddleware, (req, res) =&gt; &#123; res.send(&#x27;Hello World&#x27;);&#125;); 编写一个日志中间件 新建一个logger.js，并写入以下函数 1234567function logger(req, res, next) &#123; const time = new Date(); console.log(`[$&#123;time.toLocaleString()&#125;] $&#123;req.method&#125; $&#123;req.url&#125;`); next();&#125;module.exports = logger; 在server.js引入logger函数并且全局注册 123456const logger = require(&#x27;./logger&#x27;)......app.use(logger)...... 这样我们在访问路由后，每次都会在控制台打印一行日志，如下： 12[2023/2/27 15:54:29] GET /[2023/2/27 15:54:47] POST /about 注意：如果忘记在中间件中调用 next 函数，并且又不直接返回响应时，服务器会直接卡在这个中间件不会继续执行下去哦！ 模版引擎模版引擎可以简单的理解为升级版的html文档，express可以用模版引擎来渲染前端页面，模版引擎有很多种，包括jade, ejs, nunjunks, Handlebars等等，express对每一种都提供了很好的支持，只需要几行代码就可以使用。我们今天来学习下Handlebars。 首先，第一步是安装对应的模版引擎： 1npm install hbs 然后创建views文件夹，并且新建一个index.hbs的文件，添加如下内容： 123&lt;h1&gt;express入门课程&lt;/h1&gt;&lt;p&gt;作为前端开发，Nodejs已经成了很多公司对我们这一岗位的硬性要求，而 Express 框架则是其中知名度最高、也是最受欢迎的Nodejs开发框架。。。&lt;/p&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt; 然后再添加一个about.hbs的文件，并添加如下内容： 12&lt;h1&gt;黑马前端&lt;/h1&gt;&lt;p&gt;学前端，来黑马&lt;/p&gt; 最后便是在 server.js 中配置和使用模板。配置模板的代码非常简单： 12345// 指定模板存放目录app.set(&#x27;views&#x27;, &#x27;views&#x27;);// 指定模板引擎为 Handlebarsapp.set(&#x27;view engine&#x27;, &#x27;hbs&#x27;); 在使用模板时，只需在路由回调函数中调用 res.render 方法即可： 1234567891011121314151617// ...const app = express();app.set(&#x27;views&#x27;, &#x27;views&#x27;);app.set(&#x27;view engine&#x27;, &#x27;hbs&#x27;);app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; // 渲染index.hbs模版 res.render(&#x27;index&#x27;);&#125;);app.get(&#x27;/about&#x27;, (req, res) =&gt; &#123; // 渲染about.hbs模版 res.render(&#x27;about&#x27;);&#125;)// ... 当我们访问localhost:3000时就会加载对应的index.hbs这个模版，当我们访问localhost:3000/about时就会加载对应的about.hbs这个模版 我们还可以给模版引擎中传一些动态参数，这样就会渲染出来不同的内容，将about.hbs改成如下内容： 1234&lt;h1&gt;黑马前端&lt;/h1&gt;&lt;p&gt;学前端，来黑马&lt;/p&gt;&lt;p&gt;讲师：&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/p&gt; 然后在渲染该模版时加上第二个参数: 1234app.get(&#x27;/about&#x27;, (req, res) =&gt; &#123; // 渲染about.hbs模版 res.render(&#x27;about&#x27;, &#123; name: &#x27;jackie&#x27;, age: 18 &#125;);&#125;) 这样当渲染出来的时候就会根据我们传进去的参数动态渲染前端页面了 静态文件服务客户端一般需要访问一些图片视频等静态资源文件，那么这些文件如何发送给客户端呢，就需要用到静态文件服务了，而 Express 已经自带了静态文件服务中间件 express.static，使用起来非常方便。 假设我们的静态资源在public下面： 12345public├── css│ └── style.css└── img └── logo.png 然后我们只需要在server.js中添加一行代码： 1app.use(express.static(&#x27;public&#x27;)); 然后我们就可以通过下面的路径访问到这些资源了： 12http://localhost:3000/css/style.csshttp://localhost:3000/img/logo.png 在模板引擎中放入这些资源的引入，我们就可以模板中使用了： 12345&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot; /&gt;&lt;h1&gt;express入门课程&lt;/h1&gt;&lt;p&gt;作为前端开发，Nodejs已经成了很多公司对我们这一岗位的硬性要求，而 Express 框架则是其中知名度最高、也是最受欢迎的Nodejs开发框架。。。&lt;/p&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt; 再次运行服务器，并访问我们的网站时，就发现样式加到了我们的前端页面上了。 处理404和服务器错误我们在访问一些路由时有可能这个路由没有定义，这个时候就会返回404的状态码，或者有时候服务器内部代码出错了，就会返回500的错误码，这些情况是在开发中经常碰到的，那么服务端应该如何处理这些异常的情况呢？ 对于 404，只需在所有路由之后再加一个中间件，用来接收所有路由均匹配失败的请求 对于错误处理，前面所有中间件抛出异常时都会进入错误处理函数，可以使用 Express 自带的，也可以自定义。 处理404只需在server.js中添加如下代码： 123app.use(&#x27;*&#x27;, (req, res) =&gt; &#123; res.status(404).render(&#x27;404&#x27;, &#123; url: req.originalUrl &#125;);&#125;); 然后在views下面新建一个404.hbs的模版文件： 12&lt;h1&gt;找不到你要的页面了！&lt;/h1&gt;&lt;p&gt;你所访问的路径 &#123;&#123; url &#125;&#125; 不存在&lt;/p&gt; * 表示匹配任何路径。将此中间件放在所有路由后面，即可捕获所有访问路径均匹配失败的请求，然后渲染404的那个模版引擎就可以了。 注意：一定是放在所有路由的后面，只有前面的路由都匹配不上才会匹配到*的这个路由 处理内部错误在server.js中添加如下代码： 123app.use((err, req, res, next) =&gt; &#123; res.status(500).render(&#x27;500&#x27;);&#125;); 然后在views下面新建一个500.hbs的模版文件： 12&lt;h1&gt;服务器好像开小差了&lt;/h1&gt;&lt;p&gt;过一会儿再试试看吧！See your later~&lt;/p&gt; 注意：在server.js中添加的代码也必须要添加到所有路由的后面，不然不能处理全部的错误 我们在某个路由中手动抛出一个错误后，客户端就会渲染500.hbs这个模版文件。 总结至此express基础内容就讲解完了，这些都是express的核心知识点，后续还会有express的进阶课程，到时候会涉及到用express操作数据库和实战的内容，感兴趣的话可以关注我们的b站动态，及时跟进课程。","categories":[],"tags":[]},{"title":"寒假学习","slug":"寒假学习","date":"2024-01-12T07:32:34.988Z","updated":"2024-10-07T15:47:20.839Z","comments":true,"path":"2024/01/12/寒假学习/","permalink":"http://eastyn7.github.io/2024/01/12/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"第一周Vue2传参 查询参数传参（更适合多个参数）：?参数&#x3D;参数值 &#x3D;&gt; this.$route.query.参数名 动态路由传参（更适合单个参数）：&#x2F;路径&#x2F;参数 &#x3D;&gt; this.$route.params.参数名 组件缓存keep-alive将缓存所有切换的组件 三个属性：include——组件名数组，只有匹配的组件会被缓存 ​ exclude——组件名数组，任何匹配的组件都不会被缓存 ​ max——最多可以缓存多少组件实例 1234567&lt;template&gt; &lt;div&gt; &lt;keep-alive :include=&quot;[&#x27;LayoutPage&#x27;]&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 组件缓存了之后就不会再执行created、mounted、destroyed等钩子 提供了两个声明周期函数：activated(){} deactivated(){} 利用VueX创建仓库 利用mutations修改数据，this.$store.comit(‘方法名’) mapState映射到计算属性 mapMutations映射到方法 mapActons映射到方法 mapGetters映射到计算属性 actions处理异步，setTimeout模拟发请求 123456789actions:&#123; setAsynCount(context,num)&#123; setTimeout(()=&gt;&#123; context.comit(&#x27;changeCount&#x27;,num) &#125;,1000) &#125;&#125;this.$store.dispatch(&#x27;setAsyncCount&#x27;,200) modules模块拆分子仓，便于维护 在子模块中写namespaced: true可以直接利用mapState映射其中的内容 $store.getters[‘模块名&#x2F;xxx’] 请求拦截器12345678910111213141516171819202122232425262728293031323334353637/* 封装axios用于发送请求 */import axios from &#x27;axios&#x27;import &#123; Toast &#125; from &#x27;vant&#x27;// 创建一个新的axios实例const request = axios.create(&#123; baseURL: &#x27;http://cba.itlike.com/public/index.php?s=/api/&#x27;, timeout: 5000&#125;)// 添加请求拦截器request.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error)&#125;)// 添加响应拦截器request.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 const res = response.data console.log(res) if (res.status !== 200) &#123; // 给提示 Toast(res.message) // 抛错误promise return Promise.reject(res.message) &#125; return res&#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error)&#125;)export default request storage存储模块防止vuex刷新丢失，同时避免每次存取操作太长太麻烦的问题 12345678910111213141516171819// 约定一个通用的键名const INFO_KEY = &#x27;hm_shopping_info&#x27;// 获取个人信息export const getInfo = () =&gt; &#123; const defaultObj = &#123; token: &#x27;&#x27;, userId: &#x27;&#x27; &#125; const result = localStorage.getItem(INFO_KEY) return result ? JSON.parse(result) : defaultObj&#125;// 设置个人信息export const setInfo = (obj) =&gt; &#123; localStorage.setItem(INFO_KEY, JSON.stringify(obj))&#125;// 移除个人信息export const removeInfo = () =&gt; &#123; localStorage.removeItem(INFO_KEY)&#125; 登录节流操作1234567// 开启loading，禁止背景点击（节流处理，防止多次无效触发）Toast.loading(&#123; message: &#x27;加载中...&#x27;, forbidClick: true, // 禁止背景点击 loadingType: &#x27;spinner&#x27;, // 配置图标 duration: 0 // 不会自动消失，响应拦截器回来之后关闭&#125;) 123456789if (res.status !== 200) &#123; // 给提示 Toast(res.message) // 抛错误promise return Promise.reject(res.message)&#125; else &#123; // 正确清除loading效果 Toast.clear()&#125; 页面访问拦截设置全局前置路由 123router.beforeEach(to,from,next)=&gt;&#123; // to 往哪里去;from 从哪里来;next()是否放行,如果next()调用则放行,next(路径)拦截到某个路径页面&#125; 本周总结一直在跟着用vue2实现完整的商城项目，另外空余时间逐步在过渡vue3的基础知识，最近几天在搞三创赛需要用到的网页设计 第二周Vue31创建：npm init vue@latest setup允许在script中直接编写组合是API，setup()钩子执行时期早于beforeCreate()钩子，并且不再能使用this，数据和函数需要再setup最后return，语法糖写法省略了return template不再要求唯一根元素 reactive()和ref()reactive()作用：接受对象类型数据的参数传入并返回一个响应式的对象 12345678910111213141516&lt;script setup&gt;import &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123; count:100&#125;)const setCount = () =&gt; &#123; state.count++&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; state.count &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;setCount&quot;&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; ref()作用：接收简单类型或对象类型的数据传入并返回一个响应式的对象 ​ 本质：是在原有传入数据的基础上，外层包了一层对象 ​ 在脚本中访问数据需要通过.value，在template中不需要加.value 1234567891011121314&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)const setCount = () =&gt; &#123; count.value++&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123; state.count &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;setCount&quot;&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 组合式API-computed123456789101112131415&lt;script setup&gt;import &#123; ref,computed &#125; from &#x27;vue&#x27;const list = ref([1,2,3,4,5,6,7,8])const computedList = computed(()=&#123; return list.value.filter(item =&gt; item &gt; 2)&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;原始数据：&#123;&#123; list &#125;&#125;&lt;/div&gt; &lt;div&gt;计算后数据:&#123;&#123; computedList &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 组合式API-watch作用：侦听一个或多个数据的变化，数据变化时执行回调函数 两个额外参数：immediate（立即执行）；deep（深度监听） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;script setup&gt;import &#123; ref,watch &#125; from &#x27;vue&#x27;const count = ref(0)const nickname = ref(&#x27;张三&#x27;)const changeCount = ()=&gt;&#123; count.value++&#125;const cangeNickname = ()=&gt;&#123; nickname.value = &#x27;李四&#x27;&#125;// 监视单个watch(count,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue)&#125;) // 监视多个watch([count,nickname],(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue)&#125;) // 立即执行watch(count,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue)&#125;,&#123; immediate:true&#125;) // 深度监视[ref(简单类型)可以监听,ref(复杂类型)必须深度监听]const userInfo = ref(&#123; name:&#x27;zs&#x27;, age:18&#125;)const setUserInfo = ()=&gt;&#123; userInfo.value.age++&#125;watch(userInfo,(newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue)&#125;,&#123; deep:true&#125;) // 对于对象中的属性进行监视const userInfo = ref(&#123; name:&#x27;zs&#x27;, age:18&#125;)const setUserInfo = ()=&gt;&#123; userInfo.value.age++&#125;watch(() =&gt; userInfo.value.age,(newValue,oldValue) =&gt; &#123; console.log(newValue,oldValue)&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;changeCount&quot;&gt; 改数字 &lt;/button&gt; &lt;div&gt; &#123;&#123; nickname &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;changeNickname&quot;&gt; 改昵称 &lt;/button&gt;&lt;/template&gt; 组合式API-生命周期函数 选项式API 组合式API beforeCreate&#x2F;created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBreforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted 组合式API-父子通信父传子：父组件给子组件绑定属性，子组件内部通过props选项接收，通过defineProps“编译器宏”接收子组件传递的数据 子传父：父组件中组件标签通过@绑定事件，子组件内部通过emit方法触发事件，通过defineEmits编译器宏生成emit方法 组合式API-模板引用调用ref函数生成一个ref对象，通过ref标识绑定ref对象到标签 1234567891011121314151617181920212223242526&lt;scipt setup&gt; import TestCom from &quot;@/components/........&quot; import &#123; ref, onMounted &#125; from &#x27;vue&#x27; const inp = ref(null) // 生命钩子onMounted等dom渲染完 onMounted(()=&gt;&#123; // console.log(inp.value) // inp.value.focus() &#125;) const clickFn = ()=&gt;&#123; inp.value.focus() &#125;&lt;/scipt&gt;&lt;template&gt; &lt;div&gt; &lt;input ref=&quot;inp&quot; type=&quot;text&quot;&gt; &lt;button @click=&quot;clickFn&quot;&gt; 点击让输入框聚焦 &lt;/button&gt; &lt;/div&gt; &lt;TestCom/&gt;&lt;/template&gt; 默认情况下在语法糖下组件内部的属性和方法是不开放给父组件访问的,可以通过defineExpose编译宏指定哪些属性和方法允许访问 1234567&lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const testMessage = ref(&#x27;this is test message&#x27;) defineExpose(&#123; testMessage &#125;)&lt;/script&gt; 组合式API-provide和inject顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信 普通数据 12// 顶层组件provide(&#x27;key&#x27;,顶层组件中的数据) 12// 底层组件const message = inject(&#x27;key&#x27;) 响应式数据 12// 顶层组件provide(&#x27;app-key&#x27;,ref对象) 12// 底层组件const message = inject(&#x27;app-key&#x27;) 方法 12345// 顶层组件const setCount = () =&gt; &#123; count,value++&#125;provide(&#x27;setCount-key&#x27;,setCount) 12// 底层组件const setCount = inject(&#x27;setCount-key&#x27;) defineOptions用defineOptions定义任意的选项，props、emits、expose、slots除外 1234567&lt;script setup&gt; defineOptions(&#123; name:&#x27;&#x27;, inheritAttrs:false, ......... &#125;)&lt;/script&gt; PiniaVuex的替代品 手动添加pinia 123456789import &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import App from &#x27;./App.vue&#x27;const pinia = createPinia()const app = createApp(App)app.use(pinia)app.use(&#x27;#app&#x27;) 基础使用：定义store，组件使用store 12345678910111213141516171819202122import &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; ref,computed &#125; from &#x27;vue&#x27;// 定义store// defineStore(仓库的唯一标识),() =&gt; &#123;....&#125;)export const useCOunterStore = defineStore(&#x27;counter&#x27;,() =&gt; &#123; // 声明数据 state const count = ref(0) // 声明操作数据的方法 actions （普通函数） const addCount = () =&gt; count.value++ // 声明基于数据派生的计算属性 getters （computed） const double = computed(() =&gt; count.value * 2) return &#123; count, double, addCount &#125;&#125;) 1234567891011&lt;script setup&gt; import &#123; useCounterStore &#125; from &#x27;@/store/....&#x27; const counterStore = useCounterStore()&lt;/script&gt;&lt;template&gt; &lt;div&gt; 我是Son1.vue - &#123;&#123; counterStore.count &#125;&#125; - &#123;&#123; counterStore.double &#125;&#125; &lt;button @click=&quot;counterStore.addCount&quot;&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; stpreTpRefs - 可以使pinia产生的store解构赋值数据保持响应式 Pinia持久化——白雪localStorage 下载依赖，导入，使用 import persist from &#39;pinia-plugun-persistedstate&#39; - 导入持久化插件 app.use(pinia.use(persist)) - piania插件的安装配置 persist:true - 在组合式的第三个参数中添加开启当前模块的持久化（默认是整个state被持久化到localStorage） pnpm 第三周el-row/el-col/el-formel-row 一行分为24份 el-col :span=&quot;12&quot; 该列占12份 el-col :offset:&quot;3&quot; 左外边距3份 el-form 表单 el-form-item 表单中的每一个元素 表单校验规则 非空校验——required:true message消息提示 trigger触发校验的时机 blur(失焦时)\\change(改变时) 长度校验——min:xx max:xx 正则校验——pattern:正则规则(例如: \\^\\S{6,15}$\\ 表示6-25位的非空字符) 自定义校验——validator:(rule,value,callback) rule 当前校验规则相关的信息 value 所校验的表单元素目前的表单值 callback 无论成功还是失败都需要callback callback() 校验成功 callback(new Errir(错误信息)) 校验失败 第四周node的http模块搭建的后端服务1234567891011const http = require(&#x27;http&#x27;)const server = http.createServer(function(req,res)&#123; res.statusCode = 200 res.setHeader(&#x27;Content-Type&#x27;,&#x27;Content-Type&#x27;,&#x27;text/html&#x27;) res.send(&#x27;...&#x27;)&#125;)server.listen(3000,functon()&#123; console.log(&#x27;服务已启动&#x27;) &#125;) 运行：node server.js express搭建后端服务安装：npm install express 123456789101112const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;,function(req,res)&#123; // 相应内容 res.send(&#x27;...&#x27;)&#125;)app.listen(3000,functon()&#123; console.log(&#x27;服务已启动&#x27;) &#125;) 在 Express 中，中间件就是一个函数：1234function someMiddleware(req, res, next) &#123; // 自定义逻辑 next();&#125; 三个参数中，req 和 res 就是前面提到的 Request 请求对象和 Response 响应对象；而 next 函数则用来触发下一个中间件的执行。 全局中间件通过 app.use 函数就可以注册中间件，并且此中间件会在用户发起任何请求都可能会执行，例如： 1app.use(someMiddleware) 路由中间件通过在路由定义时注册中间件，此中间件只会在用户访问该路由时执行，例如： 123app.get(&#x27;/middleware&#x27;, someMiddleware, (req, res) =&gt; &#123; res.send(&#x27;Hello World&#x27;);&#125;); 编写一个日志中间件 新建一个logger.js，并写入以下函数 1234567function logger(req, res, next) &#123; const time = new Date(); console.log(`[$&#123;time.toLocaleString()&#125;] $&#123;req.method&#125; $&#123;req.url&#125;`); next();&#125;module.exports = logger; 在server.js引入logger函数并且全局注册 123456const logger = require(&#x27;./logger&#x27;)......app.use(logger)...... 这样我们在访问路由后，每次都会在控制台打印一行日志，如下： 12[2023/2/27 15:54:29] GET /[2023/2/27 15:54:47] POST /about 注意：如果忘记在中间件中调用 next 函数，并且又不直接返回响应时，服务器会直接卡在这个中间件不会继续执行下去哦！","categories":[],"tags":[]}],"categories":[],"tags":[]}